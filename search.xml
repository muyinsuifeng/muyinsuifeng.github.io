<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[leetcodesummary]]></title>
      <url>/2017/08/24/leetcodesummary/</url>
      <content type="html"><![CDATA[<p>利用堆栈：<br><a href="http://oj.leetcode.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="external">http://oj.leetcode.com/problems/evaluate-reverse-polish-notation/</a><br><a href="http://oj.leetcode.com/problems/longest-valid-parentheses/" target="_blank" rel="external">http://oj.leetcode.com/problems/longest-valid-parentheses/</a><br>（也可以用一维数组，贪心）<br><a href="http://oj.leetcode.com/problems/valid-parentheses/" target="_blank" rel="external">http://oj.leetcode.com/problems/valid-parentheses/</a><br><a href="http://oj.leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="external">http://oj.leetcode.com/problems/largest-rectangle-in-histogram/</a><br>特别注意细节：<a href="http://oj.leetcode.com/problems/trapping-rain-water/" target="_blank" rel="external">http://oj.leetcode.com/problems/trapping-rain-water/</a><br><a id="more"></a></p>
<p>多种数据结构：<br><a href="http://oj.leetcode.com/problems/lru-cache/" target="_blank" rel="external">http://oj.leetcode.com/problems/lru-cache/</a><br><a href="http://oj.leetcode.com/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="external">http://oj.leetcode.com/problems/substring-with-concatenation-of-all-words/</a> (注意遍历方法）<br>HASH：<a href="http://oj.leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="external">http://oj.leetcode.com/problems/longest-consecutive-sequence/</a></p>
<p>简单编程：<br><a href="http://oj.leetcode.com/problems/longest-common-prefix/" target="_blank" rel="external">http://oj.leetcode.com/problems/longest-common-prefix/</a><br><a href="http://oj.leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="external">http://oj.leetcode.com/problems/string-to-integer-atoi/</a>  (分析，控制语句）</p>
<p>排序 &amp; 查找：<br>二分查找：<a href="http://oj.leetcode.com/problems/search-a-2d-matrix/" target="_blank" rel="external">http://oj.leetcode.com/problems/search-a-2d-matrix/</a><br>二分查找进阶：<a href="http://oj.leetcode.com/problems/search-for-a-range/" target="_blank" rel="external">http://oj.leetcode.com/problems/search-for-a-range/</a><br>二分查找应用：<a href="http://oj.leetcode.com/problems/sqrtx/" target="_blank" rel="external">http://oj.leetcode.com/problems/sqrtx/</a><br>二分查找应用：<a href="http://oj.leetcode.com/problems/search-insert-position/" target="_blank" rel="external">http://oj.leetcode.com/problems/search-insert-position/</a><br>二分查找变种：<a href="http://oj.leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="external">http://oj.leetcode.com/problems/search-in-rotated-sorted-array/</a><br>二分查找变种：<a href="http://oj.leetcode.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/search-in-rotated-sorted-array-ii/</a></p>
<p>简单数学：<br><a href="http://oj.leetcode.com/problems/pascals-triangle/" target="_blank" rel="external">http://oj.leetcode.com/problems/pascals-triangle/</a><br><a href="http://oj.leetcode.com/problems/pascals-triangle-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/pascals-triangle-ii/</a><br><a href="http://oj.leetcode.com/problems/powx-n/" target="_blank" rel="external">http://oj.leetcode.com/problems/powx-n/</a><br><a href="http://oj.leetcode.com/problems/reverse-integer/" target="_blank" rel="external">http://oj.leetcode.com/problems/reverse-integer/</a><br><a href="http://oj.leetcode.com/problems/plus-one/" target="_blank" rel="external">http://oj.leetcode.com/problems/plus-one/</a><br><a href="http://oj.leetcode.com/problems/unique-paths/" target="_blank" rel="external">http://oj.leetcode.com/problems/unique-paths/</a><br><a href="http://oj.leetcode.com/problems/palindrome-number/" target="_blank" rel="external">http://oj.leetcode.com/problems/palindrome-number/</a><br><a href="http://oj.leetcode.com/problems/permutation-sequence/" target="_blank" rel="external">http://oj.leetcode.com/problems/permutation-sequence/</a><br><a href="http://oj.leetcode.com/problems/merge-intervals/" target="_blank" rel="external">http://oj.leetcode.com/problems/merge-intervals/</a><br><a href="http://oj.leetcode.com/problems/valid-number/" target="_blank" rel="external">http://oj.leetcode.com/problems/valid-number/</a><br><a href="http://oj.leetcode.com/problems/climbing-stairs/" target="_blank" rel="external">http://oj.leetcode.com/problems/climbing-stairs/</a><br><a href="http://oj.leetcode.com/problems/roman-to-integer/" target="_blank" rel="external">http://oj.leetcode.com/problems/roman-to-integer/</a><br><a href="http://oj.leetcode.com/problems/integer-to-roman/" target="_blank" rel="external">http://oj.leetcode.com/problems/integer-to-roman/</a><br><a href="http://oj.leetcode.com/problems/divide-two-integers/" target="_blank" rel="external">http://oj.leetcode.com/problems/divide-two-integers/</a><br>区间：<a href="http://oj.leetcode.com/problems/insert-interval/" target="_blank" rel="external">http://oj.leetcode.com/problems/insert-interval/</a></p>
<p>大数的数学运算：<br><a href="http://oj.leetcode.com/problems/add-binary/" target="_blank" rel="external">http://oj.leetcode.com/problems/add-binary/</a><br><a href="http://oj.leetcode.com/problems/add-two-numbers/" target="_blank" rel="external">http://oj.leetcode.com/problems/add-two-numbers/</a></p>
<p>数组：<br><a href="http://oj.leetcode.com/problems/remove-element/" target="_blank" rel="external">http://oj.leetcode.com/problems/remove-element/</a><br><a href="http://oj.leetcode.com/problems/merge-sorted-array/" target="_blank" rel="external">http://oj.leetcode.com/problems/merge-sorted-array/</a><br><a href="http://oj.leetcode.com/problems/first-missing-positive/" target="_blank" rel="external">http://oj.leetcode.com/problems/first-missing-positive/</a><br><a href="http://oj.leetcode.com/problems/spiral-matrix/" target="_blank" rel="external">http://oj.leetcode.com/problems/spiral-matrix/</a><br><a href="http://oj.leetcode.com/problems/spiral-matrix-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/spiral-matrix-ii/</a><br><a href="http://oj.leetcode.com/problems/rotate-image/" target="_blank" rel="external">http://oj.leetcode.com/problems/rotate-image/</a><br>遍历技巧：<a href="http://oj.leetcode.com/problems/container-with-most-water/" target="_blank" rel="external">http://oj.leetcode.com/problems/container-with-most-water/</a><br><a href="http://oj.leetcode.com/problems/two-sum/" target="_blank" rel="external">http://oj.leetcode.com/problems/two-sum/</a><br><a href="http://oj.leetcode.com/problems/3sum/" target="_blank" rel="external">http://oj.leetcode.com/problems/3sum/</a><br><a href="http://oj.leetcode.com/problems/3sum-closest/" target="_blank" rel="external">http://oj.leetcode.com/problems/3sum-closest/</a><br><a href="http://oj.leetcode.com/problems/4sum/" target="_blank" rel="external">http://oj.leetcode.com/problems/4sum/</a><br><a href="http://oj.leetcode.com/problems/set-matrix-zeroes/" target="_blank" rel="external">http://oj.leetcode.com/problems/set-matrix-zeroes/</a><br>用好标记数组：<a href="http://oj.leetcode.com/problems/valid-sudoku/" target="_blank" rel="external">http://oj.leetcode.com/problems/valid-sudoku/</a><br><a href="http://oj.leetcode.com/problems/next-permutation/" target="_blank" rel="external">http://oj.leetcode.com/problems/next-permutation/</a><br><a href="http://oj.leetcode.com/problems/word-search/" target="_blank" rel="external">http://oj.leetcode.com/problems/word-search/</a><br><a href="http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="external">http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/</a><br><a href="http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array-ii/</a><br><a href="http://oj.leetcode.com/problems/sort-colors/" target="_blank" rel="external">http://oj.leetcode.com/problems/sort-colors/</a></p>
<p>暴力方法/细节实现：<br><a href="http://oj.leetcode.com/problems/max-points-on-a-line/" target="_blank" rel="external">http://oj.leetcode.com/problems/max-points-on-a-line/</a></p>
<p>链表：<br>归并排序：<a href="http://oj.leetcode.com/problems/sort-list/" target="_blank" rel="external">http://oj.leetcode.com/problems/sort-list/</a><br>插入排序：<a href="http://oj.leetcode.com/problems/insertion-sort-list/" target="_blank" rel="external">http://oj.leetcode.com/problems/insertion-sort-list/</a><br>反转、插入：<a href="http://oj.leetcode.com/problems/reorder-list/" target="_blank" rel="external">http://oj.leetcode.com/problems/reorder-list/</a><br>检测是否有环：<a href="http://oj.leetcode.com/problems/linked-list-cycle/" target="_blank" rel="external">http://oj.leetcode.com/problems/linked-list-cycle/</a><br>确定链表环的起点：<a href="http://oj.leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/linked-list-cycle-ii/</a><br>Deep Copy 带有随机指针的链表：<a href="http://oj.leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="external">http://oj.leetcode.com/problems/copy-list-with-random-pointer/</a><br>链表细节：<a href="http://oj.leetcode.com/problems/rotate-list/" target="_blank" rel="external">http://oj.leetcode.com/problems/rotate-list/</a><br><a href="http://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="external">http://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/</a><br>删除细节：<a href="http://oj.leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/remove-duplicates-from-sorted-list-ii/</a><br><a href="http://oj.leetcode.com/problems/partition-list/" target="_blank" rel="external">http://oj.leetcode.com/problems/partition-list/</a><br><a href="http://oj.leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="external">http://oj.leetcode.com/problems/swap-nodes-in-pairs/</a><br>Merge 两个链表：<a href="http://oj.leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="external">http://oj.leetcode.com/problems/merge-two-sorted-lists/</a><br>Merge 多链表：<a href="http://oj.leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="external">http://oj.leetcode.com/problems/merge-k-sorted-lists/</a><br>细节：<a href="http://oj.leetcode.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="external">http://oj.leetcode.com/problems/reverse-nodes-in-k-group/</a><br><a href="http://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="external">http://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/</a><br><a href="http://oj.leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/reverse-linked-list-ii/</a></p>
<p>二叉树遍历：递归 &amp; 非递归<br><a href="http://oj.leetcode.com/problems/same-tree/" target="_blank" rel="external">http://oj.leetcode.com/problems/same-tree/</a><br>前序：<a href="http://oj.leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="external">http://oj.leetcode.com/problems/binary-tree-preorder-traversal/</a><br>中序：<a href="http://oj.leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="external">http://oj.leetcode.com/problems/binary-tree-inorder-traversal/</a><br>后序：<a href="http://oj.leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="external">http://oj.leetcode.com/problems/binary-tree-postorder-traversal/</a><br>遍历变种：<a href="http://oj.leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="external">http://oj.leetcode.com/problems/sum-root-to-leaf-numbers/</a><br>遍历变种：<a href="http://oj.leetcode.com/problems/path-sum/" target="_blank" rel="external">http://oj.leetcode.com/problems/path-sum/</a><br>遍历变种：<a href="http://oj.leetcode.com/problems/path-sum-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/path-sum-ii/</a><br>遍历变种：<a href="http://oj.leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="external">http://oj.leetcode.com/problems/maximum-depth-of-binary-tree/</a><br>遍历变种：<a href="http://oj.leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="external">http://oj.leetcode.com/problems/minimum-depth-of-binary-tree/</a><br>重建二叉树：<a href="http://oj.leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="external">http://oj.leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a><br>重建二叉树：<a href="http://oj.leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="external">http://oj.leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a><br>层次遍历变种：<a href="http://oj.leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="external">http://oj.leetcode.com/problems/binary-tree-zigzag-level-order-traversal/</a><br>遍历变种：<a href="http://oj.leetcode.com/problems/symmetric-tree/" target="_blank" rel="external">http://oj.leetcode.com/problems/symmetric-tree/</a><br>遍历应用：<a href="http://oj.leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="external">http://oj.leetcode.com/problems/binary-tree-maximum-path-sum/</a><br>遍历应用：<a href="http://oj.leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="external">http://oj.leetcode.com/problems/balanced-binary-tree/</a><br>遍历应用：<a href="http://oj.leetcode.com/problems/recover-binary-search-tree/" target="_blank" rel="external">http://oj.leetcode.com/problems/recover-binary-search-tree/</a><br>遍历应用：<a href="http://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="external">http://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/</a><br>level遍历：<a href="http://oj.leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="external">http://oj.leetcode.com/problems/binary-tree-level-order-traversal/</a><br>level 遍历：<a href="http://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/</a><br>level 遍历变种：<a href="http://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="external">http://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node/</a><br>level 遍历变种：<a href="http://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/</a></p>
<p>问题分析/智商/细节：<br><a href="http://oj.leetcode.com/problems/single-number/" target="_blank" rel="external">http://oj.leetcode.com/problems/single-number/</a><br><a href="http://oj.leetcode.com/problems/single-number-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/single-number-ii/</a><br><a href="http://oj.leetcode.com/problems/candy/" target="_blank" rel="external">http://oj.leetcode.com/problems/candy/</a>   ？<br><a href="http://oj.leetcode.com/problems/gas-station/" target="_blank" rel="external">http://oj.leetcode.com/problems/gas-station/</a></p>
<p>动态规划：<br><a href="http://oj.leetcode.com/problems/triangle/" target="_blank" rel="external">http://oj.leetcode.com/problems/triangle/</a>  （最短路径）<br><a href="http://oj.leetcode.com/problems/subsets/" target="_blank" rel="external">http://oj.leetcode.com/problems/subsets/</a> （另一种形式）<br><a href="http://oj.leetcode.com/problems/subsets-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/subsets-ii/</a><br><a href="http://oj.leetcode.com/problems/edit-distance/" target="_blank" rel="external">http://oj.leetcode.com/problems/edit-distance/</a> （经典）<br><a href="http://oj.leetcode.com/problems/word-break/" target="_blank" rel="external">http://oj.leetcode.com/problems/word-break/</a><br><a href="http://oj.leetcode.com/problems/word-break-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/word-break-ii/</a><br><a href="http://oj.leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="external">http://oj.leetcode.com/problems/unique-binary-search-trees/</a>  （动态规划避免递归）<br><a href="http://oj.leetcode.com/problems/unique-paths-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/unique-paths-ii/</a><br><a href="http://oj.leetcode.com/problems/scramble-string/" target="_blank" rel="external">http://oj.leetcode.com/problems/scramble-string/</a><br><a href="http://oj.leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="external">http://oj.leetcode.com/problems/palindrome-partitioning/</a><br><a href="http://oj.leetcode.com/problems/palindrome-partitioning-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/palindrome-partitioning-ii/</a><br><a href="http://oj.leetcode.com/problems/interleaving-string/" target="_blank" rel="external">http://oj.leetcode.com/problems/interleaving-string/</a><br><a href="http://oj.leetcode.com/problems/distinct-subsequences/" target="_blank" rel="external">http://oj.leetcode.com/problems/distinct-subsequences/</a><br><a href="http://oj.leetcode.com/problems/decode-ways/" target="_blank" rel="external">http://oj.leetcode.com/problems/decode-ways/</a><br><a href="http://oj.leetcode.com/problems/gray-code/" target="_blank" rel="external">http://oj.leetcode.com/problems/gray-code/</a><br><a href="http://oj.leetcode.com/problems/minimum-path-sum/" target="_blank" rel="external">http://oj.leetcode.com/problems/minimum-path-sum/</a></p>
<p>回溯：<br><a href="http://oj.leetcode.com/problems/combinations/" target="_blank" rel="external">http://oj.leetcode.com/problems/combinations/</a><br><a href="http://oj.leetcode.com/problems/generate-parentheses/" target="_blank" rel="external">http://oj.leetcode.com/problems/generate-parentheses/</a><br><a href="http://oj.leetcode.com/problems/combination-sum/" target="_blank" rel="external">http://oj.leetcode.com/problems/combination-sum/</a><br><a href="http://oj.leetcode.com/problems/combination-sum-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/combination-sum-ii/</a><br><a href="http://oj.leetcode.com/problems/sudoku-solver/" target="_blank" rel="external">http://oj.leetcode.com/problems/sudoku-solver/</a><br>经典N皇后：<a href="http://oj.leetcode.com/problems/n-queens/" target="_blank" rel="external">http://oj.leetcode.com/problems/n-queens/</a><br><a href="http://oj.leetcode.com/problems/n-queens-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/n-queens-ii/</a><br><a href="http://oj.leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="external">http://oj.leetcode.com/problems/letter-combinations-of-a-phone-number/</a></p>
<p>贪心：<br><a href="http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="external">http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/</a><br><a href="http://oj.leetcode.com/problems/jump-game/" target="_blank" rel="external">http://oj.leetcode.com/problems/jump-game/</a><br><a href="http://oj.leetcode.com/problems/jump-game-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/jump-game-ii/</a><br><a href="http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/</a><br><a href="http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="external">http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/</a><br><a href="http://oj.leetcode.com/problems/maximum-subarray/" target="_blank" rel="external">http://oj.leetcode.com/problems/maximum-subarray/</a><br><a href="http://oj.leetcode.com/problems/minimum-window-substring/" target="_blank" rel="external">http://oj.leetcode.com/problems/minimum-window-substring/</a><br><a href="http://oj.leetcode.com/problems/maximal-rectangle/" target="_blank" rel="external">http://oj.leetcode.com/problems/maximal-rectangle/</a><br><a href="http://oj.leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="external">http://oj.leetcode.com/problems/longest-substring-without-repeating-characters/</a></p>
<p>分治 &amp; 递归：<br><a href="http://oj.leetcode.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/unique-binary-search-trees-ii/</a><br><a href="http://oj.leetcode.com/problems/restore-ip-addresses/" target="_blank" rel="external">http://oj.leetcode.com/problems/restore-ip-addresses/</a>  （时间复杂度有限，递归满足）<br><a href="http://oj.leetcode.com/problems/permutations/" target="_blank" rel="external">http://oj.leetcode.com/problems/permutations/</a><br><a href="http://oj.leetcode.com/problems/permutations-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/permutations-ii/</a><br><a href="http://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="external">http://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/</a><br><a href="http://oj.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="external">http://oj.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/</a><br><a href="http://oj.leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="external">http://oj.leetcode.com/problems/median-of-two-sorted-arrays/</a><br><a href="http://oj.leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="external">http://oj.leetcode.com/problems/validate-binary-search-tree/</a></p>
<p>字符串：<br><a href="http://oj.leetcode.com/problems/count-and-say/" target="_blank" rel="external">http://oj.leetcode.com/problems/count-and-say/</a><br><a href="http://oj.leetcode.com/problems/implement-strstr/" target="_blank" rel="external">http://oj.leetcode.com/problems/implement-strstr/</a>  （子串查找）<br><a href="http://oj.leetcode.com/problems/anagrams/" target="_blank" rel="external">http://oj.leetcode.com/problems/anagrams/</a><br><a href="http://oj.leetcode.com/problems/text-justification/" target="_blank" rel="external">http://oj.leetcode.com/problems/text-justification/</a> (细节）<br><a href="http://oj.leetcode.com/problems/simplify-path/" target="_blank" rel="external">http://oj.leetcode.com/problems/simplify-path/</a>  （基础控制语句 if-else-for）<br><a href="http://oj.leetcode.com/problems/multiply-strings/" target="_blank" rel="external">http://oj.leetcode.com/problems/multiply-strings/</a><br><a href="http://oj.leetcode.com/problems/regular-expression-matching/" target="_blank" rel="external">http://oj.leetcode.com/problems/regular-expression-matching/</a><br><a href="http://oj.leetcode.com/problems/wildcard-matching/" target="_blank" rel="external">http://oj.leetcode.com/problems/wildcard-matching/</a><br><a href="http://oj.leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="external">http://oj.leetcode.com/problems/longest-palindromic-substring/</a><br><a href="http://oj.leetcode.com/problems/zigzag-conversion/" target="_blank" rel="external">http://oj.leetcode.com/problems/zigzag-conversion/</a><br><a href="http://oj.leetcode.com/problems/length-of-last-word/" target="_blank" rel="external">http://oj.leetcode.com/problems/length-of-last-word/</a><br><a href="http://oj.leetcode.com/problems/valid-palindrome/" target="_blank" rel="external">http://oj.leetcode.com/problems/valid-palindrome/</a></p>
<p>图：<br>深搜/广搜：<a href="http://oj.leetcode.com/problems/clone-graph/" target="_blank" rel="external">http://oj.leetcode.com/problems/clone-graph/</a></p>
<p>搜索 &amp; 遍历：<br><a href="http://oj.leetcode.com/problems/word-ladder/" target="_blank" rel="external">http://oj.leetcode.com/problems/word-ladder/</a><br><a href="http://oj.leetcode.com/problems/word-ladder-ii/" target="_blank" rel="external">http://oj.leetcode.com/problems/word-ladder-ii/</a><br>广搜：<a href="http://oj.leetcode.com/problems/surrounded-regions/" target="_blank" rel="external">http://oj.leetcode.com/problems/surrounded-regions/</a></p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[dp-algorithm]]></title>
      <url>/2017/08/24/dp-algorithm/</url>
      <content type="html"><![CDATA[<h1 id="1、三角形找一条从底到顶的最小路径"><a href="#1、三角形找一条从底到顶的最小路径" class="headerlink" title="1、三角形找一条从底到顶的最小路径"></a>1、三角形找一条从底到顶的最小路径</h1><pre><code>    [a1]
   [b1,b2]
  [c1,c2,c3]
 [d1,d2,d3,d4]
[... ... ... ..]
</code></pre><a id="more"></a>
<pre><code>思路:可以从倒数第二排开始把，下面一排相邻的俩个的最小值加到该位置上
     然后依次向上计算，到顶时，就是从底到顶的最小路径
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mininumTotal</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = v.size()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; ++i)&#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].size(); ++j)</div><div class="line">            v[i][j] += max( v[i+<span class="number">1</span>][j], v[i+<span class="number">1</span>][j+<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> v[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="2、最大字数和"><a href="#2、最大字数和" class="headerlink" title="2、最大字数和"></a>2、最大字数和</h1><pre><code>求一个数组连续下标和的最大值（数组元素可正可负可为0）
思路:
令cursum(i)表示数组下标以i为起点往0看的最大连续下标最大的和，而maxsum(i)
表示前i个元素的最大子数组之和。那么我们就可以推出下一个maxsum(i+1)
应该为cursum(i+1)和maxsum(i)中选取一个最大值。递推式为：
cursum(i) = max{A[i],cursum(i-1)+A[i]};//判断当前cursum(i-1)和为负数的时
                                       //候，重新从i开始统计
maxsum(i) = max{maxsum(i-1),cursum(i)}
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubArray</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> cursum;</div><div class="line">    <span class="keyword">int</span> maxsum;</div><div class="line">    sursum = maxsum = v[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.size(); ++i)&#123;</div><div class="line">        curmax = max( curmax + v[i], v[i]);</div><div class="line">        maxsum = max( maxsum, curmax);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxsum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-1-扩展问题"><a href="#2-1-扩展问题" class="headerlink" title="2.1 扩展问题:"></a>2.1 扩展问题:</h2><pre><code>如果数组是环形的
</code></pre><h3 id="2-1-1"><a href="#2-1-1" class="headerlink" title="2.1.1"></a>2.1.1</h3><pre><code>方法一:将数组copy一份连接到原数组后面，用上面的方法求解
</code></pre><h3 id="2-1-2"><a href="#2-1-2" class="headerlink" title="2.1.2"></a>2.1.2</h3><pre><code>方法二:先用原解求出没有跨过边界的max1，然后求出从A[0]开始的最大段(A[0]-A[j])
       然后求出从A[n-1]向前的最大段(A[i]-A[n-1]),刚好可以使用curmax.如果i&lt;=j
       则max2=A[0]+..+A[n-1]否则max2 = A[0]+...+A[j]+A[i]+...A[n-1]
       最后max = max(max1,max2);
</code></pre><h2 id="2-2-扩展问题"><a href="#2-2-扩展问题" class="headerlink" title="2.2 扩展问题:"></a>2.2 扩展问题:</h2><pre><code>如果是求和的绝对值最大子串
</code></pre><h3 id="2-2-1"><a href="#2-2-1" class="headerlink" title="2.2.1"></a>2.2.1</h3><pre><code>思路:先计算所有sum[0-j] 0&lt;= j &lt;n，然后对sum[0-j]的数组进行排序，那么对于任何i,j段
        的和等于：sum[i-j]= sum[0-j] - sum[0-i];设置数组sum用来存储子数组0-j的和  
        因为已经对sum进行了排序，排序后只需要找到sum[sum.size()-1]-sum[0],sum[z]  
        (0&lt;=z&lt;sum.size())的绝对值的最大值即可。z为排序后的索引  
        如果是sum[z]情形，z为排序后的索引，则maxAbs = abs(sum[0-i])  
        如果是sum[sum.size()-1]-sum[0]情形，则maxAbs = abs(sum[i]-sum[j])  
        时间复杂度：o(nlogn) 空间复杂度：o(n) 
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAbsSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span></span>&#123;  </div><div class="line">    <span class="keyword">if</span>(num.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">    <span class="keyword">if</span>(num.size()==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">abs</span>(num[<span class="number">0</span>]);  </div><div class="line">    <span class="keyword">int</span> max_abs_sum;  </div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum;  </div><div class="line">    <span class="keyword">int</span> cur_sum = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num.size(); i++)&#123;  </div><div class="line">        cur_sum += num[i];  </div><div class="line">        <span class="keyword">if</span>(cur_sum == <span class="number">0</span>)  </div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">        sum.push_back(cur_sum);  </div><div class="line">    &#125;  </div><div class="line">    sort(sum.begin(), sum.end());  </div><div class="line">    max_abs_sum = <span class="built_in">abs</span>(sum[sum.size()<span class="number">-1</span>]-sum[<span class="number">0</span>]);  <span class="comment">//2 -5 10 -1 5 -1</span></div><div class="line">                                            <span class="comment">//sum   2 -3 7  6  11 10</span></div><div class="line">                                            <span class="comment">//        __       __ </span></div><div class="line">                                        <span class="comment">//reorder  -3  2 6  7 10  11</span></div><div class="line">                                        <span class="comment">//max_abs_sum  11-(-3) = 14</span></div><div class="line">                                        <span class="comment">//max(sum)     11</span></div><div class="line">                                        <span class="comment">//=&gt;  max = 14</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sum.size(); i++) &#123;  </div><div class="line">        cur_sum = <span class="built_in">abs</span>(sum[i]);  </div><div class="line">        <span class="keyword">if</span>(cur_sum&gt;max_abs_sum)  </div><div class="line">            max_abs_sum = cur_sum;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> max_abs_sum;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="3、回文最小化分次数"><a href="#3、回文最小化分次数" class="headerlink" title="3、回文最小化分次数"></a>3、回文最小化分次数</h1><pre><code>给定字符串S，使得每个子串为回文子串，的最小划分次数
思路:
dp[i] = min(dp[j]+1) 这里j &lt; i&amp;&amp; [j+1,i]是一个回文子串
    &lt;1&gt;现将dp[i]+1赋给dp[i+1]
    &lt;2&gt;然后依次判断[k,i+1](0&lt;k&lt;=i+1)是不是回文，是的话将dp[i+1] = dp[k-1]+1
       求出dp[i+1]的最小值
    &lt;3&gt;求到最后得出结果
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(;startIndex&lt;endIndex;startIndex++,endIndex--)</div><div class="line">        <span class="keyword">if</span>(s[startIndex]!=s[endIndex]) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(s.size()+<span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</div><div class="line">        dp[i+<span class="number">1</span>] = dp[i]+<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.size(); ++j)&#123;</div><div class="line">            <span class="keyword">if</span>( isPalindrome(s, j, i))</div><div class="line">                <span class="keyword">if</span>(dp[i+<span class="number">1</span>] &gt; dp[j]+<span class="number">1</span>)</div><div class="line">                    dp[i+<span class="number">1</span>] = dp[j]+<span class="number">1</span>;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[s.size()];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>上面这种方法的isPalindrome的方法复杂度太大总时间复杂度有 o(n^3)
所以要把判断回文的方法取简，定义二维数组P[n][n] =&gt; if [i,j]是回文，则p[i][j] = #include &lt;future&gt;
p[i][j] = (s[i] == s[j] &amp;&amp; p[i+1][j-1])
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n =s.size();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; p(n , <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        dp[i+<span class="number">1</span>] = dp[n]+<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; ++i)</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; --j)&#123;</div><div class="line">            <span class="keyword">if</span>( s[i] == s[j]&amp;&amp; (i - j &lt; <span class="number">2</span>|| p[i<span class="number">-1</span>][j+<span class="number">1</span>]))&#123;</div><div class="line">                p[i][j] = <span class="literal">true</span>;</div><div class="line">                dp[i] = min(dp[i],dp[j<span class="number">-1</span>]+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span> f[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="4、最佳时间买卖股票"><a href="#4、最佳时间买卖股票" class="headerlink" title="4、最佳时间买卖股票"></a>4、最佳时间买卖股票</h1><h2 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h2><pre><code>给一个数prices[]，prices[i]代表股票在第i天的售价，求出只做一次交易(一次买入和卖出)能得到的最大收益。
非dp问题，只要找出最大的差值即可
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prices)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(prices.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> low = prices[<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.size(); i++)&#123;</div><div class="line">        <span class="keyword">if</span>(prices[i] &lt; low) low = prices[i];</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(prices[i] - low &gt; ans) ans = prices[i] - low;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-2、不限交易次数"><a href="#4-2、不限交易次数" class="headerlink" title="4.2、不限交易次数"></a>4.2、不限交易次数</h2><pre><code>非dp问题 ：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prices)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(prices.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.size(); i++)&#123;</div><div class="line">        <span class="keyword">if</span>(prices[i] &gt; prices[i<span class="number">-1</span>])</div><div class="line">            ans += prices[i]-prices[i<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-3、此题是限制在两次交易内"><a href="#4-3、此题是限制在两次交易内" class="headerlink" title="4.3、此题是限制在两次交易内"></a>4.3、此题是限制在两次交易内</h2><pre><code>dp问题
</code></pre><h3 id="4-3-1-方法一"><a href="#4-3-1-方法一" class="headerlink" title="4.3.1 方法一:"></a>4.3.1 方法一:</h3><pre><code>把prices分成prices[0,m]和prices[m,prices.size()-1]然后分别用4.1的方法计算，要做n次划分所以时间复杂度是 O(n^2)
            这是一个非dp的算法，复杂度比较高
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prices)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m&lt;prices.size(); m++)&#123;</div><div class="line">        <span class="keyword">int</span> tmp = maxProfitOnce(prices, <span class="number">0</span>, m) + maxProfitOnce(prices, m, prices.size()<span class="number">-1</span>);</div><div class="line">        <span class="keyword">if</span>(tmp &gt; ans) ans = tmp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfitOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prices,<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> low = prices[start];</div><div class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>; i&lt;=end; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(prices[i] &lt; low) low = prices[i];</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(prices[i] - low &gt; ans) ans = prices[i] - low;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-3-2-方法二-dp算法"><a href="#4-3-2-方法二-dp算法" class="headerlink" title="4.3.2 方法二:dp算法,"></a>4.3.2 方法二:dp算法,</h3><pre><code>&lt;1&gt;先用4.1的方法计算出子序列[0,...,i]中的最大利润，用数组保存。O(n)
&lt;2&gt;逆向扫描，计算子序列[i, ... ,n-1]上的最大利润。 O(n)也就是说把maxProfitOnce过程变为 O(1)从而使得中的复杂度降为 O(n)
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prices)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(prices.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> n = prices.size();</div><div class="line"></div><div class="line">    <span class="comment">//正向遍历，opt[i]表示 prices[0...i]内做一次交易的最大收益.</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; opt(n, <span class="number">0</span>);</div><div class="line">    opt[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> low = prices[<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> curAns = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, valley = prices[<span class="number">0</span>]; i &lt; n; ++i) &#123;</div><div class="line">        valley = min(valley, prices[i]);</div><div class="line">        opt[i] = max(opt[i - <span class="number">1</span>], prices[i] - valley);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//逆向遍历, opt[i]表示 prices[i...n-1]内做一次交易的最大收益.</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; optReverse(n, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>, peak = prices[n - <span class="number">1</span>]; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">        peak = max(peak, prices[i]);</div><div class="line">        optReverse[i] = max(optReverse[i], peak - prices[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//再进行划分，分别计算两个部分</span></div><div class="line">    <span class="keyword">int</span> max_profit = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        max_profit = max(max_profit, opt[i] + optReverse[i]);</div><div class="line">    <span class="keyword">return</span> max_profit;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-4-Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#4-4-Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="4.4 Leetcode 309. Best Time to Buy and Sell Stock with Cooldown"></a>4.4 Leetcode 309. Best Time to Buy and Sell Stock with Cooldown</h2><pre><code>dp 问题，在每次售出股票之后有一天的冷冻期 不可以买股票
    思路：
        可以考虑一共有三种状态设为state0, state1,state2
        这三种状态的转移关系有

            state0--buy--&gt;state1--sell--&gt;state2
            ^ |  ^        ^ |              |  
            | |  |        | |              |
            ---  |        ---              |
                 --------cool down----------
        state0[i] = max( state0[i-1], state2[i-1]);
        state1[i] = max( state1[i-1], state0[i-1] - prices[i]);
        state2[i] = state1[i-1] + prices[i];
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = prices.size();</div><div class="line">    <span class="keyword">if</span>( n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; state0( n);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; state1( n);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; state2( n);</div><div class="line">    state0[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">    state1[<span class="number">0</span>] = INT_MIN;</div><div class="line">    state2[<span class="number">0</span>] = INT_MIN;    </div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</div><div class="line">        state0[i] = max( state0[i - <span class="number">1</span>], state2[i - <span class="number">1</span>]);</div><div class="line">        state1[i] = max( state1[i - <span class="number">1</span>], state0[i - <span class="number">1</span>] - prices[i]);</div><div class="line">        state2[i] = state1[i - <span class="number">1</span>] + prices[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max( state0[n<span class="number">-1</span>], state2[n<span class="number">-1</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="5、判断字符串s3是否由s1-s2交叉存取组成"><a href="#5、判断字符串s3是否由s1-s2交叉存取组成" class="headerlink" title="5、判断字符串s3是否由s1,s2交叉存取组成"></a>5、判断字符串s3是否由s1,s2交叉存取组成</h1><pre><code>For example,
Given:
s1 = &quot;aabcc&quot;,
s2 = &quot;dbbca&quot;,
When s3 = &quot;aa dbbc bc a c&quot;, return true.
When s3 = &quot;aa dbbb (error)accc&quot;, return false.

思路:
    设状态dp[i][j]，表示s1[0,i]和s2[0,j]匹配s3[0,i+j].如果s1的最后一个字符等于s3的最后一个字符，则
    dp[i][j]=dp[i-1][j]；
    如果s2的最后一个字符等于s3的最后一个字符，则 
    dp[i][j]=dp[i][j-1]。
    因此状态转移方程如下： 
    dp[i][j] = (s1[i - 1] == s3 [i + j - 1] &amp;&amp; dp[i - 1][j]) || (s2[j - 1] == s3 [i + j - 1] &amp;&amp; dp[i][j - 1]);
    1 |d0|b0|b0|c0|a0|
    ------------------
    a1|0 |0 |0 |0 |0 |
    ------------------
    a1|d1|b1|b1|c1|0 |
    ------------------
    b0|b1|b1|0 |b1|0 |
    ------------------
    c0|0 |c1|b1|c1|a1|
    ------------------
    c0|0 |0 |c1|0 |c1|
    ------------------
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( s1.size() + s2.size() != s3.size()) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; dp(s1.size()+<span class="number">1</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s2.size()+<span class="number">1</span>, <span class="literal">false</span>));</div><div class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s1.size(); ++i)</div><div class="line">        <span class="keyword">if</span>( dp[i][<span class="number">0</span>] &amp;&amp; s1[i<span class="number">-1</span>] == s3[i<span class="number">-1</span>]) dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s2.size(); ++i)</div><div class="line">        <span class="keyword">if</span>( dp[<span class="number">0</span>][i] &amp;&amp; s2[i<span class="number">-1</span>] == s3[i<span class="number">-1</span>]) dp[<span class="number">0</span>][i] = <span class="literal">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= s1.size(); ++i)</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= s2.size(); ++j)</div><div class="line">            <span class="keyword">if</span>( (dp[i<span class="number">-1</span>][j]&amp;&amp;s1[i<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>])||(dp[i][j<span class="number">-1</span>]&amp;&amp;s2[j<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]))</div><div class="line">                dp[i][j] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> dp[s1.size()][s2.size()];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>上面这个算法的时间复杂度是 O(n^2) 空间复杂度是 O(n^2)
但如果改由最小的那个string的长度来存的话空间复杂度可以降低到 O(n)
使用到了滚动数组的原理来将空间复杂度降低
1 |d0|b0|b0|c0|a0| dp(s2.size())
------------------
a1|0 |0 |0 |0 |0 | dp(s2.size())
------------------
a1|d1|b1|b1|c1|0 | dp(s2.size())
------------------
b0|b1|b1|0 |b1|0 | dp(s2.size())
------------------
c0|0 |c1|b1|c1|a1| dp(s2.size())
------------------
c0|0 |0 |c1|0 |c1| dp(s2.size())
------------------
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>( s1.size() + s2.size() != s3.size()) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (s1.size() &lt; s2.size())</div><div class="line">        <span class="keyword">return</span> isInterleave(s2, s1, s3);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(s2.size() + <span class="number">1</span>, <span class="literal">true</span>);</div><div class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s2.size(); ++i)</div><div class="line">        dp[i] = s2[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>];</div><div class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s1.size(); ++i)&#123;</div><div class="line">        dp[<span class="number">0</span>] = s1[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>] &amp;&amp; dp[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s2.size(); ++j)</div><div class="line">            dp[j] = (s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[j]) || (s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[j - <span class="number">1</span>]); </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[s2.size()];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="6、给定一个矩形表格，求从顶到底的最小和"><a href="#6、给定一个矩形表格，求从顶到底的最小和" class="headerlink" title="6、给定一个矩形表格，求从顶到底的最小和"></a>6、给定一个矩形表格，求从顶到底的最小和</h1><pre><code>给一个矩阵表格，其中只有非负数，找到一条从[0,0]到[i,j] 的最小路径和，只能左右走
思路:
设dp[i][j]是从[0,0]到[i,j]的路径和，则转移方程是
dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + array[i][j];
</code></pre><h2 id="6-1-备忘录法（递归）"><a href="#6-1-备忘录法（递归）" class="headerlink" title="6.1 备忘录法（递归）"></a>6.1 备忘录法（递归）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;<span class="built_in">array</span>, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) <span class="keyword">return</span> INT_MAX; <span class="comment">// 越界，终止条件，注意，不是 0</span></div><div class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">array</span>[<span class="number">0</span>][<span class="number">0</span>]; <span class="comment">// 回到起点，收敛条件</span></div><div class="line">    <span class="keyword">return</span> min(getOrUpdate(<span class="built_in">array</span>, x - <span class="number">1</span>, y), getOrUpdate(<span class="built_in">array</span>, x, y - <span class="number">1</span>))</div><div class="line">         + <span class="built_in">array</span>[x][y];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getOrUpdate</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;<span class="built_in">array</span>, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) </div><div class="line">            <span class="keyword">return</span> INT_MAX; <span class="comment">// 越界，注意，不是 0</span></div><div class="line">    <span class="keyword">if</span> (dp[x][y] &gt;= <span class="number">0</span>) <span class="comment">//dp &gt;= 0 更新</span></div><div class="line">            <span class="keyword">return</span> dp[x][y];</div><div class="line">    <span class="keyword">else</span></div><div class="line">         <span class="keyword">return</span> dp[x][y] = dfs(<span class="built_in">array</span>, x, y);<span class="comment">//dp = -1 获取</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m = <span class="built_in">array</span>.size();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="built_in">array</span>[<span class="number">0</span>].size();</div><div class="line">    dp = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;(m, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">-1</span>));</div><div class="line">    <span class="keyword">return</span> dfs(<span class="built_in">array</span>, m<span class="number">-1</span>, n<span class="number">-1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6-2-二维动态规划"><a href="#6-2-二维动态规划" class="headerlink" title="6.2 二维动态规划"></a>6.2 二维动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>( <span class="built_in">array</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m = <span class="built_in">array</span>.size();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="built_in">array</span>[<span class="number">0</span>].size();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(m, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;);</div><div class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">array</span>[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</div><div class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="built_in">array</span>[i][<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</div><div class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-1</span>] + <span class="built_in">array</span>[<span class="number">0</span>][i];</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</div><div class="line">            dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+<span class="built_in">array</span>[i][j];</div><div class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6-3-动态规划-O-n-2-滚动数组-O-n"><a href="#6-3-动态规划-O-n-2-滚动数组-O-n" class="headerlink" title="6.3 动态规划 O(n^2) + 滚动数组 O(n)"></a>6.3 动态规划 O(n^2) + 滚动数组 O(n)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>( <span class="built_in">array</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m = <span class="built_in">array</span>.size();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="built_in">array</span>[<span class="number">0</span>].size();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, INT_MAX);</div><div class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</div><div class="line">        dp[<span class="number">0</span>] += <span class="built_in">array</span>[i][<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</div><div class="line">            dp[j] = min(dp[j<span class="number">-1</span>], dp[j]) + <span class="built_in">array</span>[i][j];<span class="comment">//滚动数组dp[j]是更新前的dp[j]相当于dp[i-1][j]</span></div><div class="line">                                                      <span class="comment">//dp[j-1]是同一排前一个dp相当于dp[i][j-1]</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="7、使俩字符串相等所需要的最小编辑次数"><a href="#7、使俩字符串相等所需要的最小编辑次数" class="headerlink" title="7、使俩字符串相等所需要的最小编辑次数"></a>7、使俩字符串相等所需要的最小编辑次数</h1><pre><code>每次只能有一个步骤：&lt;1&gt;插入&lt;2&gt;删除&lt;3&gt;替换
思路:
    设状态dp[i][j]表示为A[0,i]和B[0,j]之间的最小编辑距离。
    假设A[0,i]形式为str1c,B[0,j]形式为str2d
    &lt;1&gt;如果c == d则dp[i][j] = dp[i-1][j-1]
    &lt;2&gt;如果c != d，
        &lt;1&gt;如果c替换成d，则dp[i][j] = dp[i-1][j-1]+1
        &lt;2&gt;如果在c后面添加一个d，则dp[i][j] = dp[i][j-1] + 1
        &lt;3&gt;如果将c删除，则dp[i][j] = dp[i-1][j] + 1
        &lt;4&gt;然后取这四种情况的最小值
</code></pre><h2 id="7-1-二维动态规划-O-nm-O-nm"><a href="#7-1-二维动态规划-O-nm-O-nm" class="headerlink" title="7.1 二维动态规划 O(nm) O(nm)"></a>7.1 二维动态规划 O(n<em>m) O(n</em>m)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; word1, <span class="keyword">const</span> <span class="built_in">string</span> &amp; word2)</span></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = word1.size();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m = word2.size();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(n+<span class="number">1</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>));</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        dp[i][<span class="number">0</span>] = i;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</div><div class="line">        dp[<span class="number">0</span>][i] = i;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j)&#123;</div><div class="line">            <span class="keyword">if</span>( word1[i] == word2[j])</div><div class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</div><div class="line">            <span class="keyword">else</span></div><div class="line">                dp[i][j] = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])) + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span> dp[n,m];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="7-2-动态规划-O-n-m-滚动数组-O-m"><a href="#7-2-动态规划-O-n-m-滚动数组-O-m" class="headerlink" title="7.2 动态规划  O(n*m) + 滚动数组 O(m)"></a>7.2 动态规划  O(n*m) + 滚动数组 O(m)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; word1, <span class="keyword">const</span> <span class="built_in">string</span> &amp; word2)</span></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = word1.size();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m = word2.size();</div><div class="line">    <span class="keyword">if</span>( n &lt; m) minDistance( word2, word1);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m+<span class="number">1</span>);</div><div class="line">    <span class="keyword">int</span> record = <span class="number">0</span>;<span class="comment">//记录dp[i-1][j-1]</span></div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</div><div class="line">        dp[i] = i;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</div><div class="line">        record = dp[<span class="number">0</span>];</div><div class="line">        dp[<span class="number">0</span>] = i;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j)&#123;</div><div class="line">            <span class="keyword">int</span> pre_record = dp[j];</div><div class="line">            <span class="keyword">if</span>( word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])</div><div class="line">                dp[j] = pre_record;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                dp[j] = min( record, min( dp[j],dp[j<span class="number">-1</span>]));</div><div class="line">            record = pre_record;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[m];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="8、给定一串数字，1对应A，2对应B-26对应Z，求有多少种解码方式"><a href="#8、给定一串数字，1对应A，2对应B-26对应Z，求有多少种解码方式" class="headerlink" title="8、给定一串数字，1对应A，2对应B,26对应Z，求有多少种解码方式"></a>8、给定一串数字，1对应A，2对应B,26对应Z，求有多少种解码方式</h1><pre><code>例如：12 可以被翻译为1 2=&gt; AB 也可以被翻译为12=&gt; L,所以12的解码方式数是2
思路:
    和爬楼梯问题是一样的，
    爬楼梯问题是一个人每次可以上1层或者2层楼梯问上到第n层有多少种走法
    设dp[n]表示爬n阶楼梯的不同方法，为了爬到第n阶楼梯，有俩中选择
        &lt;1&gt;从第n-1阶楼梯前进1步
        &lt;2&gt;从第n-2阶楼梯前进2步
        所以得出dp[n] = dp[n-1] + dp[n-2]

解码这个问题就是问一个两位数 (最多到26，这里要判断一下)是按一个一个数来解码还是把它看做一个俩位数来解码
</code></pre><h2 id="8-1-动态规划-O-n-滚动数组-O-1"><a href="#8-1-动态规划-O-n-滚动数组-O-1" class="headerlink" title="8.1 动态规划 O(n) + 滚动数组 O(1)"></a>8.1 动态规划 O(n) + 滚动数组 O(1)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>( s.empty()||s[<span class="number">0</span>] == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>;<span class="comment">//dp[0] = 0;</span></div><div class="line">    <span class="keyword">int</span> cur = <span class="number">1</span>;<span class="comment">//dp[1] = 1;</span></div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); ++i)&#123;</div><div class="line">        <span class="keyword">if</span>( s[i<span class="number">-1</span>] == <span class="string">'0'</span>)</div><div class="line">            cur = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>( i &lt; <span class="number">2</span>||!(s[i<span class="number">-2</span>] == <span class="string">'1'</span>|| (s[i<span class="number">-2</span>] == <span class="string">'2'</span>&amp;&amp;s[i<span class="number">-1</span>] &lt;= <span class="string">'6'</span>)))<span class="comment">//判断一下是否可以当做俩位数来解</span></div><div class="line">            pre = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> tmp = cur;</div><div class="line">        cur = pre + cur;<span class="comment">//dp[n] = dp[n-1] + dp[n-2]</span></div><div class="line">        prev = tmp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cur;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="9、不同的子序列Distinct-Subsequences"><a href="#9、不同的子序列Distinct-Subsequences" class="headerlink" title="9、不同的子序列Distinct Subsequences"></a>9、不同的子序列Distinct Subsequences</h1><pre><code>给定两个字符串a，b求b在a中出现的次数，要求可以是不连续的，但是b在a中的顺序必须和b以前的一致。 
例如： a = &apos;rabbbit&apos; b = &apos;rabbit&apos; 
//          rabb it
//          rab bit
//          ra bbit
            所以返回3
思路: 
    类似一个数字分解的问题
    设dp[i][j] 表示b的前j个字符在a的前i个字符中出现的次数
        &lt;1&gt;如果a[i] == b[j] 那么dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
            意思是：如果当前a[i] == b[j]，那么当前这个字母即可以保留也可以抛弃，所以变换方法等于保留这个字母的变换方法加上不用这个字母的变换方法。
        &lt;2&gt;如果a[i] != b[j] 那么dp[i][j] = dp[i-1][j]
            就是指当当前字符不等的时候，只能抛弃当前字符
        dp[0][0] = 1, dp[i][0] = 0 (把任意一个字符串变换为一个空串只有一个方法)

      1|r0|a0|b0|b0|i0|t0| std::vector&lt;int&gt; dp(m+1);
    ----------------------
    r 0|r1|0 |0 |0 |0 |0 |
    ----------------------
    a 0|1 |a1|0 |0 |0 |0 |
    ----------------------
    b 0|0 |1 |b1|b0|0 |0 |
    ----------------------
    b 0|0 |1 |b2|b1|0 |0 |
    ----------------------
    b 0|0 |1 |b3|b3|0 |0 |
    ----------------------
    i 0|0 |1 |3 |3 |i3|0 |
    ----------------------
    t 0|0 |1 |3 |3 |3 |t3|
    ----------------------
</code></pre><h2 id="9-1-动态规划-O-nm-O-nm"><a href="#9-1-动态规划-O-nm-O-nm" class="headerlink" title="9.1 动态规划 O(nm) O(nm)"></a>9.1 动态规划 O(n<em>m) O(n</em>m)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b)</span> </span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = a.size();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m = b.size();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(n+<span class="number">1</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>));</div><div class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)&#123;</div><div class="line">            <span class="keyword">if</span>( a[i<span class="number">-1</span>] == b[j<span class="number">-1</span>]) </div><div class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j];</div><div class="line">            <span class="keyword">else</span></div><div class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[n][m];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="9-2-动态规划-O-n-m-滚动数组-O-n"><a href="#9-2-动态规划-O-n-m-滚动数组-O-n" class="headerlink" title="9.2 动态规划 O(n*m) + 滚动数组 O(n)"></a>9.2 动态规划 O(n*m) + 滚动数组 O(n)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b)</span> </span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = a.size();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m = b.size();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m+<span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)&#123;</div><div class="line">            dp[j] = (a[i] == b[j])? (dp[j] + dp[j<span class="number">-1</span>]):dp[j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[m];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="10、单词分解Word-Break"><a href="#10、单词分解Word-Break" class="headerlink" title="10、单词分解Word Break"></a>10、单词分解Word Break</h1><pre><code>字符串是否可以分解为给定的单词
例如:s = &quot;catsanddog&quot;.
dict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;].
A solution is [&quot;cats and dog&quot;, &quot;cat sand dog&quot;].
思路:
    和第一题一样的思路，就是要返回所有有可能的切分位置，如果用回溯来处理切分的话肯定是会超时
    所以设dp[i][j]来表示[i-j]这一段是否可以切分，然后在dfs的时候利用看最后剩余的子串能否切分来剪枝
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="keyword">int</span> k,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt;&amp; dp,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; had,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans,<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;dict)</span>  </span>&#123;  </div><div class="line">    <span class="keyword">int</span> n=s.length();  </div><div class="line">    <span class="keyword">if</span>(k&gt;=n)&#123;  </div><div class="line">        <span class="keyword">if</span>(!had.empty())&#123;  </div><div class="line">            <span class="built_in">string</span> ret;  </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;had.size();i++) &#123;  </div><div class="line">                ret.append(had[i]);  </div><div class="line">                <span class="keyword">if</span>(i!=had.size()<span class="number">-1</span>)  </div><div class="line">                    ret.push_back(<span class="string">' '</span>);  </div><div class="line">            &#125;  </div><div class="line">            ans.push_back(ret);  </div><div class="line">            <span class="keyword">return</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;k+len&lt;=n;len++)&#123;  </div><div class="line">        <span class="built_in">string</span> tmp=s.substr(k,len);  </div><div class="line">        <span class="keyword">if</span>(dict.count(tmp)&gt;<span class="number">0</span> &amp;&amp; dp[n-k-len][k+len])&#123;  </div><div class="line">            had.push_back(tmp);  </div><div class="line">            dfs(s,k+len,dp,had,ans,dict);  </div><div class="line">            had.pop_back();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;     </div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; wordBreak(<span class="built_in">string</span> s, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;dict)&#123;</div><div class="line">    <span class="keyword">int</span> n = s.size();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; dp(n+<span class="number">1</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; (n+<span class="number">1</span>, <span class="literal">false</span>));</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">0</span>; ++i)</div><div class="line">        dp[<span class="number">0</span>][i] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; ++len)&#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> start = <span class="number">0</span>;start + len &lt;= n; ++start)&#123;</div><div class="line">            <span class="built_in">string</span> tmp = s.substr(start, len);</div><div class="line">            <span class="keyword">if</span>( dict.count(tmp) &gt; <span class="number">0</span>)</div><div class="line">                dp[len][start] = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">for</span>( <span class="keyword">int</span> left = <span class="number">1</span>; left &lt; len; ++left)&#123;</div><div class="line">                    dp[len][start] = dp[left][start] &amp;&amp; dp[len-left][start+left];  </div><div class="line">                    <span class="keyword">if</span>( dp[len][start]) <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>( dp[n][<span class="number">0</span>] == <span class="literal">false</span>)</div><div class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; had;</div><div class="line">    dfs( s, <span class="number">0</span> , dp, had, ans dict);</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="11、最大可整除的子集合-368-Largest-Divisible-Subset"><a href="#11、最大可整除的子集合-368-Largest-Divisible-Subset" class="headerlink" title="11、最大可整除的子集合//368. Largest Divisible Subset"></a>11、最大可整除的子集合//368. Largest Divisible Subset</h1><pre><code>给定一个数组，求这样一个子集合，集合中的任意两个数相互取余均为0，然后子集合的长度要最长
思路:
    较小数对较大数取余一定为0，那么问题就变成了看较大数能不能整除这个较小数。那么如果数组是无序的，处理起来就比较麻烦，所以我们首先可以先给数组排序
    然后设dp[i]为排序后到nums[i]最大可整除的子集合的长度,设parent[i]表示上一个整除i的整数的位置(即使用数组链表来存储输出vector)，设maxlength为最大可整除的子集合的长度，begin_index
    表示最大可整除的子集合的长度在nums中的起始下标。
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; largestDivisibleSubset(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">    sort( nums.begin(), nums.end());</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(  nums.size(), <span class="number">0</span>), parent( nums.size(), <span class="number">0</span>);</div><div class="line">    <span class="keyword">int</span> maxlength = <span class="number">0</span>, begin_index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i; j &lt; nums.size(); ++j)&#123;</div><div class="line">            <span class="keyword">if</span>( nums[j] % nums[i] == <span class="number">0</span>&amp;&amp; dp[i] &lt; dp[j]+<span class="number">1</span>)&#123;</div><div class="line">                dp[i] = dp[j] + <span class="number">1</span>;</div><div class="line">                parent[i] = j;</div><div class="line">                <span class="keyword">if</span>( maxlength &lt; dp[i])&#123;</div><div class="line">                    maxlength = dp[i];</div><div class="line">                    begin_index = i;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">    <span class="keyword">while</span>( maxlength--)&#123;</div><div class="line">        res.push_back(nums[begin_index]);</div><div class="line">        begin_index = parent[begin_index];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="12、Count-Primes计算质数"><a href="#12、Count-Primes计算质数" class="headerlink" title="12、Count Primes计算质数"></a>12、Count Primes计算质数</h1><pre><code>计算0-n中质数的个数
思路:
    解题方法就在第二个提示埃拉托斯特尼筛法Sieve of Eratosthenes（必须把不大于根号n的所有素数的
    倍数剔除，剩下的就是素数。）中，这个算法的过程如下图所示，
    我们从2开始遍历到根号n，先找到第一个质数2，然后将其所有的倍数全部标记出来，然后到下一个质
    数3，标记其所有倍数，一次类推，直到根号n，此时数组中未被标记的数字就是质数。我们需要一个
    n-1长度的bool型数组来记录每个数字是否被标记，长度为n-1的原因是题目说是小于n的质数个数，并
    不包括n
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v(n, <span class="literal">true</span>);</div><div class="line">    v[<span class="number">0</span>] = <span class="literal">false</span>;</div><div class="line">    v[<span class="number">1</span>] = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); ++i)</div><div class="line">        <span class="keyword">if</span>( v[i])</div><div class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i*<span class="number">2</span>; j &lt; n; j += j)</div><div class="line">                v[j] = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">int</span> count = <span class="built_in">std</span>::count_if(v.begin(), v.end(),[](<span class="keyword">bool</span> x)&#123; <span class="keyword">return</span> x;&#125;);</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="13、丑数ugly-numberII和super-ugly-number"><a href="#13、丑数ugly-numberII和super-ugly-number" class="headerlink" title="13、丑数ugly numberII和super ugly number"></a>13、丑数ugly numberII和super ugly number</h1><pre><code>丑数是指质因数因子只能是2,3,5的数
</code></pre><h2 id="13-1-ugly-numberII-求第n个丑数"><a href="#13-1-ugly-numberII-求第n个丑数" class="headerlink" title="13.1 ugly numberII 求第n个丑数"></a>13.1 ugly numberII 求第n个丑数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//从1开始取2,3,5倍数的最小值，并记录2,3,5之前最近和谁乘过</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">    <span class="keyword">int</span> t2 = <span class="number">0</span>,t3 = <span class="number">0</span>,t5 = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</div><div class="line">        <span class="keyword">int</span> tmp;</div><div class="line">        tmp = min(<span class="number">2</span>*v[t2],<span class="number">3</span>*v[t3]);</div><div class="line">        tmp = min(<span class="number">5</span>*v[t5],tmp);</div><div class="line">        <span class="keyword">if</span>( tmp  == <span class="number">2</span>*v[t2]) t2 ++;</div><div class="line">        <span class="keyword">if</span>( tmp  == <span class="number">3</span>*v[t3]) t3 ++;</div><div class="line">        <span class="keyword">if</span>( tmp  == <span class="number">5</span>*v[t5]) t5 ++;</div><div class="line">        res.push_back(tmp);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> v[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="13-2-super-ugly-number"><a href="#13-2-super-ugly-number" class="headerlink" title="13.2 super ugly number"></a>13.2 super ugly number</h2><pre><code>质数因子变成了任意给定，然后求第n个丑数求法和ugly numberII的思路是一致的，只是把记录2,3,5使用次数的t2,t3,t5变成了可变的vector
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; primes)</span> </span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>), idx(primes.size(), <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</div><div class="line">        dp[i] = INT_MAX;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.size(); ++j) &#123;</div><div class="line">            dp[i] = min(dp[i], dp[idx[j]] * primes[j]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.size(); ++j) &#123;</div><div class="line">            <span class="keyword">if</span> (dp[i] == dp[idx[j]] * primes[j]) &#123;</div><div class="line">                ++idx[j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp.back();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="14、Leetcode-474-Ones-and-Zeroes"><a href="#14、Leetcode-474-Ones-and-Zeroes" class="headerlink" title="14、Leetcode 474. Ones and Zeroes"></a>14、Leetcode 474. Ones and Zeroes</h1><pre><code>假设你分别有m个0s和n个1s。 另一方面，有一个字符串只包含0和1的数组。 
现在您的任务是找到可以使用给定m 0和n 1形成的最大字符串数。 每个0和1最多可以使用一次。
例如Array = {&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;}, m = 5, n = 3
    最多可以合成 &quot;10&quot; &quot;0001&quot; &quot;1&quot; &quot;0&quot;共用了5个0和3个1
    所以返回4
思路: 
    假设dp[i][j]是指用m个0s 和n个1s可以合成的最大的string数
    那么dp[i][j] = max( dp[i][j] , dp[i-string.countof(0)][j-string.countof(1)])
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp( m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;( n+<span class="number">1</span>, <span class="number">0</span>));</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> s : strs)&#123;</div><div class="line">        <span class="keyword">int</span> numZeroes = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> numOnes = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</div><div class="line">          <span class="keyword">if</span> (c == <span class="string">'0'</span>)</div><div class="line">            numZeroes++;</div><div class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'1'</span>)</div><div class="line">            numOnes++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = m; i &gt;= numZeroes; --i)</div><div class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = n; j &gt;= numOnes; --j)</div><div class="line">                dp[i][j] = max( dp[i][j], dp[i - numZeroes][j - numOnes] + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[m][n];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="15、Leetcode-516-Longest-Palindromic-Subsequence"><a href="#15、Leetcode-516-Longest-Palindromic-Subsequence" class="headerlink" title="15、Leetcode 516. Longest Palindromic Subsequence"></a>15、Leetcode 516. Longest Palindromic Subsequence</h1><pre><code>给定一个string，求最长的回文字串的长度
例如： s = &quot;bbbab&quot; 返回结果是4 最长回文字串是&quot;bbb b&quot;
思路：
    假设dp[i][j]是[i,j]的最长回文字串
    在初始时，如果i == j 的话dp[i][j] = 1;
              如果i+1 == j时 如果s[i] == s[j] dp[i][j] = 2;
                             如果s[i] != s[j] dp[i][j] = 1;
    随后，如果s[i] == s[j] dp[i][j] = max( dp[i+1][j], dp[i][j-1], dp[i+1][j-1]+2);
              s[i] != s[j] dp[i][j] = max( dp[i+1][j], dp[i][j-1], dp[i+1][j-1]);
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = s.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp( n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i; j &lt; n; ++j)&#123;</div><div class="line">            <span class="keyword">if</span>( i == j) dp[i][j] = <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>( i+<span class="number">1</span> == j) &#123;</div><div class="line">                <span class="keyword">if</span>( s[i] == s[j])</div><div class="line">                    dp[i][j] = <span class="number">2</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    dp[i][j] = <span class="number">1</span>;</div><div class="line">            &#125;    </div><div class="line">        &#125;</div><div class="line">    <span class="comment">// for( auto i : dp)&#123;</span></div><div class="line">    <span class="comment">//     for( auto j : i)</span></div><div class="line">    <span class="comment">//         cout &lt;&lt; j &lt;&lt; ends;</span></div><div class="line">    <span class="comment">//     cout &lt;&lt; endl;</span></div><div class="line">    <span class="comment">// &#125;</span></div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n - <span class="number">3</span>; i &gt;= <span class="number">0</span>; --i)</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i+<span class="number">2</span>; j &lt; n; ++j)&#123;</div><div class="line">            <span class="keyword">if</span>( s[i] == s[j])</div><div class="line">                dp[i][j] = max( dp[i+<span class="number">1</span>][j], max(dp[i][j<span class="number">-1</span>], dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>));</div><div class="line">            <span class="keyword">else</span></div><div class="line">                dp[i][j] = max( dp[i+<span class="number">1</span>][j], max(dp[i][j<span class="number">-1</span>], dp[i+<span class="number">1</span>][j<span class="number">-1</span>]));</div><div class="line">        &#125;</div><div class="line">    <span class="comment">// for( auto i : dp)&#123;</span></div><div class="line">    <span class="comment">//     for( auto j : i)</span></div><div class="line">    <span class="comment">//         cout &lt;&lt; j &lt;&lt; ends;</span></div><div class="line">    <span class="comment">//     cout &lt;&lt; endl;</span></div><div class="line">    <span class="comment">// &#125; </span></div><div class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="16、-Leetcode-486-Predict-the-Winner"><a href="#16、-Leetcode-486-Predict-the-Winner" class="headerlink" title="16、 Leetcode 486. Predict the Winner"></a>16、 Leetcode 486. Predict the Winner</h1><pre><code>给一个数组，a和b分别从数组的俩端中任意一端取数，问能否a最后取得的数和大于等于b的
例如：[1, 5, 233, 7] a先选1 剩下[5, 233, 7] b只能取5或者7,接下来a可以取233所以a可以赢b，返回true
思路：假设dp的上三角[i][j]存的是[i,j]a可以取到的最大和，下三角存的是[i,j]所有数的和
    初始化dp[i][i] = nums[i]
    |  1|  5|233|  7|
    -----------------
   1|  1|   |   |   |
    -----------------
   5|  6|  5|   |   |
    -----------------
 233|239|238|233|   |
    -----------------
   7|246|245|240|  7|
    -----------------
    然后dp[i][j] = max( sum[i][j] - dp[i+1][j], sum[i][j] - dp[i][i-1]);
    |  1|  5|233|  7|
    -----------------
   1|  1|  5|234|234|
    -----------------
   5|  6|  5|233| 12|
    -----------------
 233|239|238|233|233|
    -----------------
   7|246|245|240|  7|
    -----------------
    最后求出的dp[0][n-1]就是a可以取到的最大数和，dp[n-1][0]-dp[0][n-1]是b可以取到的最小数和
    俩数相减如果大于等于0则返回true
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = nums.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp( n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        dp[i][i] = nums[i];</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</div><div class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j] + nums[i];</div><div class="line">    <span class="comment">// for( auto i : dp)&#123;</span></div><div class="line">    <span class="comment">//     for( auto j : i)</span></div><div class="line">    <span class="comment">//         cout &lt;&lt; j &lt;&lt; ends;</span></div><div class="line">    <span class="comment">//     cout &lt;&lt; endl;</span></div><div class="line">    <span class="comment">// &#125;</span></div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)</div><div class="line">            dp[i][j] = max( dp[j][i] - dp[i+<span class="number">1</span>][j], dp[j][i] - dp[i][j<span class="number">-1</span>]);</div><div class="line">    <span class="comment">// for( auto i : dp)&#123;</span></div><div class="line">    <span class="comment">//     for( auto j : i)</span></div><div class="line">    <span class="comment">//         cout &lt;&lt; j &lt;&lt; ends;</span></div><div class="line">    <span class="comment">//     cout &lt;&lt; endl;</span></div><div class="line">    <span class="comment">// &#125;</span></div><div class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>] &gt;= ( dp[n<span class="number">-1</span>][<span class="number">0</span>] - dp[<span class="number">0</span>][n<span class="number">-1</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="17、-Leetcode-416-Partition-Equal-Subset-Sum-其实是一个01背包问题"><a href="#17、-Leetcode-416-Partition-Equal-Subset-Sum-其实是一个01背包问题" class="headerlink" title="17、 Leetcode 416. Partition Equal Subset Sum (其实是一个01背包问题)"></a>17、 Leetcode 416. Partition Equal Subset Sum (其实是一个01背包问题)</h1><pre><code>给定一个数组问这个数组能否被分解为两个子数组，俩子数组的和相等
例如： [1,5,11,5] =&gt; [1,5,5] [11] 返回true
思路：要使俩子数组的和相等，其实就是问能不能取出一个子数组 使其的和等于原数组和sum的一半
    先求出sum如果sum为奇数，返回false，
                      偶数，设dp[sum/2+1]存的dp[i]是i能否用数组的数字求和得到
                      dp[i] = dp[i] || dp[i-nums[j]]
    0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11|12|
    1  0  0  0  0  0  0  0  0  0  0  0  0
1   1  1  0  0  0  0  0  0  0  0  0  0  0 
5   1  1  0  0  0  1  1  0  0  0  0  0  0  
11  1  1  0  0  0  1  1  0  0  0  0  1  1  
5   1  1  0  0  0  1  1  0  0  0  1  1  1  
</code></pre><h2 id="17-1-dp"><a href="#17-1-dp" class="headerlink" title="17.1 dp"></a>17.1 dp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> sum = accumulate( nums.begin(), nums.end(), <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span>( sum&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(sum/<span class="number">2</span>+<span class="number">1</span>, <span class="literal">false</span>);</div><div class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> i : nums)</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = sum/<span class="number">2</span>; j &gt;= i; --j)</div><div class="line">            dp[j] = dp[j] || dp[j - i];</div><div class="line">    <span class="keyword">return</span> dp[sum/<span class="number">2</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="17-2-bit-operation-用bitset来记录上面数组记录的数据"><a href="#17-2-bit-operation-用bitset来记录上面数组记录的数据" class="headerlink" title="17.2 bit operation(用bitset来记录上面数组记录的数据)"></a>17.2 bit operation(用bitset来记录上面数组记录的数据)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">    <span class="built_in">bitset</span>&lt;5001&gt; bits(<span class="number">1</span>);</div><div class="line">    <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) bits |= bits &lt;&lt; n;</div><div class="line">    <span class="keyword">return</span> !(sum &amp; <span class="number">1</span>) &amp;&amp; bits[sum &gt;&gt; <span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="18、0-1背包问题及其变种"><a href="#18、0-1背包问题及其变种" class="headerlink" title="18、0/1背包问题及其变种"></a>18、0/1背包问题及其变种</h1><h2 id="18-1-01背包问题"><a href="#18-1-01背包问题" class="headerlink" title="18.1 01背包问题"></a>18.1 01背包问题</h2><pre><code>有N件物品和一个容量为V的背包，第i件物品的重量为c[i],价值为w[i].求解哪些物品放入背包，可以使物品的总重量不超过背包容量，且价值最大
    思路：
    最基本的背包问题，每件物品仅有一件，可放可不放
    设dp[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值
    dp[i][v] = max( dp[i-1][v], dp[i-1][v-c[i]] + w[i])
    注意：dp[i][v]当且仅当存在一个前i件物品的子集，其费用总和为v，所以在最后推完之后，最终的答案不是dp[N][v]而是max(dp[N][0-v])

    其中空间复杂度和时间复杂度都为 O(N*V),但是空间复杂度可以使用滚动数组的方式优化到 O(V)
    for i = 1..N
        for v = V..0
            dp[v] = max( dp[v], dp[v-c[i]] + w[i])
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Time O(N*V) Space O(V)</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bag</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w, <span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = c.size();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(v+<span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = v; j &gt;= <span class="number">0</span>; --j)</div><div class="line">            <span class="keyword">if</span>( j - c[i] &gt;= <span class="number">0</span>)</div><div class="line">                dp[j] = max( dp[j], dp[j - c[i]]+ w[i]);</div><div class="line">    <span class="keyword">return</span> dp[v];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="18-2-完全背包问题"><a href="#18-2-完全背包问题" class="headerlink" title="18.2 完全背包问题"></a>18.2 完全背包问题</h2><pre><code>有N件物品和一个容量为V的背包，每种物品有无限件可以用。第i件的重量是c[i]，价值是w[i]。求解哪些物品放入背包，可以使物品的总重量不超过背包容量，且价值最大
    思路：
    这和01背包问题不同的是，每件物品可以取0,1,2...件。如果任然按照01背包求解的思路，令dp[i][v]表示前i种物品恰放入容器为v的背包的最大价值。
    可写出dp[i][v] = max( dp[i-1][v-k*c[i]] + k*w[i]|0&lt;=k*c[i]&lt;=v)
    但是求解每个状态的时间不是常数了，总复杂度超过了O(VN)

    优化：
    如果俩件物品i，j满足c[i] &lt;= c[j]且w[i] &gt;= w[j]，则将物品j去掉不考虑。这样可以减少物品的件数来加快速度

    进一步优化：
    把第i种物品拆成重量为c[i]*(2^k)、价值为w[i]*(2^k)的若干件物品，其中k满足c[i]*(2^k) &lt; V (这是二进制的思想，不管最优策略选几件第i件物品，总可以表示成若干个2^k件物品的和)
    这样把每种物品拆成O(log(V/c[i]))件物品
    可以得出
    for i = 1..N
        for v = 0..V
            dp[v] = max( dp[v], dp[v-c[i]] + w[i])

    这里相对于01背包问题只是v的循环顺序改变了，是因为反序的话可以保证每个物品只用到一次，正序可以让这个物品用到0..n次
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bag</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w, <span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = c.size();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(v+<span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v+<span class="number">1</span>; ++j)</div><div class="line">            <span class="keyword">if</span>( j - c[i] &gt;= <span class="number">0</span>)</div><div class="line">                dp[j] = max( dp[j], dp[j - c[i]]+ w[i]);</div><div class="line">    <span class="keyword">return</span> dp[v];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="18-3-多重背包问题"><a href="#18-3-多重背包问题" class="headerlink" title="18.3 多重背包问题"></a>18.3 多重背包问题</h2><pre><code>有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件重量是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。
    思路：
    和完全背包类似，只是每种物品有数量上限，令dp[i][v]表示前i种物品恰放入容器为v的背包的最大价值。
    dp[i][v]=max{dp[i-1][v-k*c[i]]+ k*w[i]|0&lt;=k&lt;=n[i]}

    给出一种方法，将原来的数量k的物品拆成若干组，每一组可以看做一件新的物品，其重量和价值为改组中所有物品的价值重量的总和，每组物品包含的元物品个数可拆为：1,2,4,(k-1)^(c+1)
    其中c为使(k-2)^(c+1)大于0的最大整数。这样就将物品数量大大降低，同时通过对这些若干个原物品组合得到的新物品的不同组合，可以得到0到k之间的任意件物品的价值重量和，所以对所有
    这些新物品做0-1背包，即可得到多重背包的解。转化之后的时间复杂度为O(V*∑ni=1^(log2(ki)))。
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 时间复杂度：O(m*∑log k[i])</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiBag</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;w, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;n, <span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newc;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; neww;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size(); ++i)&#123;<span class="comment">//把n[i]个第i种物品按照 1 2 4 8 ...(二进制优化)分成若干物品，就变成了01背包问题</span></div><div class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>( n[i] - k &gt; <span class="number">0</span>)&#123;</div><div class="line">            n[i] -= k;</div><div class="line">            newc.push_back( c[i]*k);</div><div class="line">            neww.push_back( w[i]*k);</div><div class="line">            k *= <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        newc.push_back( c[i]*n[i]);</div><div class="line">        neww.push_back( w[i]*n[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m = newc.size();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(v+<span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)<span class="comment">//对于新的物品来进行01背包问题求解</span></div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = v; j &gt;= newc[i]; --j)</div><div class="line">                dp[j] = max( dp[j], dp[j - newc[i]]+ neww[i]);</div><div class="line">    <span class="keyword">return</span> dp[v];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>使用单调队列的方法可以将上面的二进制优化的复杂度降低到 O(v*i)
</code></pre><p><a href="link">http://blog.csdn.net/u013923947/article/details/40371243</a></p>
<pre><code>首先前面的多重背包的原始转移方程式
num[i] = min( n[i], j/c[i])//第i件物品最多可以取多少件
dp[i][j] = max( dp[i-1][j-k*c[i]] + k*w[i]) (1&lt;=k&lt;=num[i])

先看一个例子
取num[i] = 2,c[i] = c, w[i] = w, V &gt; 9*c
j = 6*c : dp[i][j] = max( dp[i-1][6*c], dp[i-1][6*c - c] + w, dp[i-1][6*c - 2*c] + 2*w)
                   = max( dp[i-1][6*c], dp[i-1][5*c] + w, dp[i-1][4*c] + 2*w)
j = 5*c : dp[i][j] = max( dp[i-1][5*c], dp[i-1][4*c] + w, dp[i-1][3*c] + 2*w)
j = 4*c : dp[i][j] = max( dp[i-1][4*c], dp[i-1][3*c] + w, dp[i-1][2*c] + 2*w)               
令f(j) = dp[i-1][j]的话
j = 6*c : dp[i][j] = max( f( 6*c), f( 5*c) + w, f( 4*c) + 2*w)
j = 5*c : dp[i][j] = max( f( 5*c), f( 4*c) + w, f( 3*c) + 2*w)
j = 4*c : dp[i][j] = max( f( 4*c), f( 3*c) + w, f( 2*c) + 2*w)              
=&gt;但如果将j = 6*v时，每项减去6*w，j=5*v时，每项减去5*w，j=4*v时，每项减去4*w，就得到：
j = 6*c : dp[i][j] = max( f( 6*c) - 6*w, f( 5*c) - 5*w, f( 4*c) - 4*w) + 6*w
j = 5*c : dp[i][j] = max( f( 5*c) - 5*w, f( 4*c) - 4*w, f( 3*c) - 3*w) + 5*w
j = 4*c : dp[i][j] = max( f( 4*c) - 4*w, f( 3*c) - 3*w, f( 2*c) - 2*w) + 4*w            
其中有很多的重复项

所以令a = j/c[i] , b = j%c[i] 那么j = a*c[i] + b
那么dp[i][j] = max( dp[i-1][b+(a-k)*c[i]] + k*w[i]) 
=&gt;dp[i][j] = max( dp[i-1][b+k*c[i]] - k*w[i]) + a*w[i] (k = a-k)=&gt;( a-num[i]&lt;=k&lt;=a)

对于dp[i-1][y] (y = b, b+d, b+2*d ... j)
dp[i][j]就是求j的前面num[i] + 1个数对应的dp[i-1][b+k*c[i]] - k*w[i]的最大值再加上a*w[i]
如果将dp[i][j]前面所有的dp[i-1][b+k*c[i]] - k*w[i]放入到一个队列中，那么，dp[i][j]就是求
这个队列最大长度num[i]+1时，队列中的最大值，在加上a*w[i].从而把原问题转换为在O(1)的时间内
求一个队列的最大值。

解决求一个队列的最大值：
    &lt;1&gt;用另一个队列B记录指定队列的最大值(或则记录最大值的下标),并通过下面俩个操作保证队列B的第一个元素
    (或指向的元素)一定是指定队列的当前最大值
    &lt;2&gt;当指定队列有元素M进入时，删除B队列中比M小的(或则队列B中所指向的元素小于等于M的)所有元素，并将M
    (或M的地址)存入B中
    &lt;3&gt;当指定队列有M 离开时，队列B的第一个元素若与M相等(或则队列B第一个元素的地址与M一样)，则队列B的第
    一个元素也离队
    上诉方法可以保证B中的第一个元素(或则指向的元素)一定是指定队列所有元素的最大值
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//“多重背包”通用模板  </span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V = <span class="number">100004</span>;  </div><div class="line"><span class="comment">//c、n、w：当前所处理的这类物品的体积、个数、价值  </span></div><div class="line"><span class="comment">//V：背包体积， MAX_V：背包的体积上限值  </span></div><div class="line"><span class="comment">//dp[i]：体积为i的背包装前几种物品，能达到的价值上限。  </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pack</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp, <span class="keyword">int</span> V, <span class="keyword">int</span> c, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span>  </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || c == <span class="number">0</span>) <span class="keyword">return</span>;  </div><div class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;               <span class="comment">//01背包  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = V; i &gt;= c; --i)  </div><div class="line">            <span class="keyword">if</span> (dp[i] &lt; dp[i - c] + w) dp[i] = dp[i - c] + w;  </div><div class="line">        <span class="keyword">return</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">if</span> (n * c &gt;= V - c + <span class="number">1</span>) &#123;   <span class="comment">//完全背包(n &gt;= V / c)  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = c; i &lt;= V; ++i)  </div><div class="line">            <span class="keyword">if</span> (dp[i] &lt; dp[i - c] + w) dp[i] = dp[i - c] + w;  </div><div class="line">        <span class="keyword">return</span>;      </div><div class="line">    &#125;     </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> va[MAX_V], vb[MAX_V];   <span class="comment">//va/vb: 主/辅助队列  </span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; ++j) &#123;     <span class="comment">//多重背包  </span></div><div class="line">        <span class="keyword">int</span> *pb = va, *pe = va - <span class="number">1</span>;     <span class="comment">//pb/pe分别指向队列首/末元素  </span></div><div class="line">        <span class="keyword">int</span> *qb = vb, *qe = vb - <span class="number">1</span>;     <span class="comment">//qb/qe分别指向辅助队列首/末元素    </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = j, i = <span class="number">0</span>; k &lt;= V; k += c, ++i) &#123;  </div><div class="line">            <span class="keyword">if</span> (pe  == pb + n) &#123;       <span class="comment">//若队列大小达到指定值，第一个元素X出队。  </span></div><div class="line">                <span class="keyword">if</span> (*pb == *qb) ++qb;   <span class="comment">//若辅助队列第一个元素等于X，该元素也出队。   </span></div><div class="line">                ++pb;  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">int</span> tt = dp[k] - i * w;  </div><div class="line">            *++pe = tt;                  <span class="comment">//元素X进队  </span></div><div class="line">            <span class="comment">//删除辅助队列所有小于X的元素，qb到qe单调递减，也可以用二分法  </span></div><div class="line">            <span class="keyword">while</span> (qe &gt;= qb &amp;&amp; *qe &lt; tt) --qe;  </div><div class="line">            *++qe = tt;              <span class="comment">//元素X也存放入辅助队列          </span></div><div class="line">            dp[k] = *qb + i * w;      <span class="comment">//辅助队列首元素恒为指定队列所有元素的最大值  </span></div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiBag</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; n, <span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(v+<span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size(); ++i)</div><div class="line">        pack( dp, v, c[i], n[i], w[i]);</div><div class="line">    <span class="keyword">return</span> dp[v];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>对于01背包、完全背包、多重背包问题都不是很难，但是如果把它们组合起来就比较难了，需要把题目拆分成
简单的背包问题来求解
</code></pre><h2 id="18-4-二维背包问题"><a href="#18-4-二维背包问题" class="headerlink" title="18.4 二维背包问题"></a>18.4 二维背包问题</h2><pre><code>二维费用 的背包问题，对于每种物品，具有俩种不同的费用。选择这件物品必须同时付出这两种代价，对于每种代价都有一个
    可付出的最大值(背包容量)。问怎样选择物品可以得到 最大的价值。设这两种代价分别为代价1 和代价2，第i件的两种代价分
    别为a[i]和b[i]。两种代价可付出的最大值(两背包的容量)分别为V和U，物品的价值为w[i].

    思路：
        把费用加一维，状态也加一维即可。
        设dp[i][v][u]表示前i种物品付出的两种代价分别为v和u的时候可获得的最大价值
        转移方程为: dp[i][v][u] = max( dp[i-1][v][u], dp[i-1][v-a[i]][u-b[i]] + w[i])

        物品总个数的限制：
        有时候，&quot;二维费用&quot;的条件是以这样一种隐含的方式给出的，最多只能取M件物品，事实上相当于每件物品多了一种&quot;件数&quot;的费
        用，每个物品的件数费用均为1，可以付出的最大件数费用为M。换句话说，dp[v][m]表示付出费用v,最多选m件时可以取得的最
        大价值，则根据物品的类型(01,完全，多重)用不同的方法循环更新，最后在dp[0...V][0...M]中得到答案

        如果恰取M件的话，在dp[0..V][M]中寻找答案
</code></pre><h2 id="18-5-分组背包问题"><a href="#18-5-分组背包问题" class="headerlink" title="18.5 分组背包问题"></a>18.5 分组背包问题</h2><pre><code>有N件物品和一个容量为V的背包，第i件物品的重量为c[i]价值为w[i]。这些物品被划分为若干组，每组中的物品相互冲突，最
    多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 

    思路：
        这个问题变成了每组物品有若干种策略：是选择本组的某一种还是一件都不选。也就是说
        设dp[k][v]表示前k组物品花费v的费用能取得的最大价值，则有
        dp[k][v] = max( dp[k-1][v], dp[k-1][v-c[i]] + w[i]) 物品i属于第k组

        然后使用滚动数组优化可得下列伪代码
        for 所有的组k
            for 所有属于k组的i
                for v = V..0
                    dp[v] = max( dp[v], dp[v-c[i]] + w[i])
</code></pre><h2 id="18-6-有依赖的背包问题"><a href="#18-6-有依赖的背包问题" class="headerlink" title="18.6 有依赖的背包问题"></a>18.6 有依赖的背包问题</h2><pre><code>这种背包问题的物品间存在某种&apos;依赖&apos;关系。也就是说，i依赖于j，表示选择物品i则必须选择 物品j。为了简化起见，这里先设
    没有物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。 

    思路：
    我们将不依赖于别的物品的物品称为&apos;主件&apos;，依赖于某个主件的物品称为&apos;附件&apos;。这道题就可以变成，可知多有的物品由若干主件
    和依赖于没个主件的一个附件的集合组成。
    按照背包问题的思路，仅考虑一个主件和它的附件集合。可是，这样有非常多的策略：
        &lt;1&gt;一个也不选
        &lt;2&gt;仅仅选主件
        &lt;3&gt;选主件后选一个附件
        ...
        这无法用状态转移方程来表示
    考虑到所有的策略是互斥的 (只能选一个)，所以一个主件和它的附件集合实际上对应于上面的背包分组问题中的一个物品组，每个
    选择了组件又选择了若干附件的策略吟对于这个物品组中的一个物品，其费用和价值都是这个策略的物品的值的和。但仅仅是这一步转化
    并不能给出一个好算法，因为，物品组中的物品数没变，还是想原问题中一样多

    再考虑到，可以对每组中的物品使用滚动数组的方法进行优化，这提示我们，对于一个物品组中的物品，所有费用相同的物品只留一个价
    值最大的，这不会影响结果。所以，我们可以对主件i的附件集合先进性一次01背包，得到费用一次为0..V-c[i]所有这些值时相应的最大
    价值dp[0..V-c[i]]。那么这个主件及它的附件集合相当于V-c[i]+1个物品的物品组(把附件取重量0..V-c[i]所能取到的最大重量看做V-c[i]
    +1个物品，然后这些物品的重量就是用01问题解出来的相应的最大值，然后根据分组问题的互斥原理，只能从这个分组中取一个)，其中费用
    为c[i]+k的物品的价值为dp[k] + w[i]。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件i转化为 V-c[i]+1
    个物品的物品组，就可以直接应用分组背包问题算法解决问题了。

    在考虑更一般的问题：
    依赖关系是以&apos;森林&apos;的形式给出，只有每个物品最多依赖于一个物品，且不出现循环依赖

    思路：
    解决这个问题，仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作
    01背包问题来求解了，若这个附件也有集合，则他必定要被先转化成物品组，然后用分组的背包问题接触主件及其附件组中各个费用的附件所对应
    的价值。事实上，这是一种树形DP，其特点是每个父节点都需要对它的各个儿子的属性进行一次DP以求得自己的相关属性。
</code></pre><h2 id="18-7-泛化物品"><a href="#18-7-泛化物品" class="headerlink" title="18.7 泛化物品"></a>18.7 泛化物品</h2><pre><code>定义：
    考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。
    更严格的定义之。在背包容量为V的背包问题中，泛化物品是一个定义域为0..V中的整数的函数h，当分配给它的费用为v时，能得到的价值就是h(v)。 
    这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组h[0..V]，给它费用v，可得到价值h[V]。 

    一个费用为c价值为w的物品，如果在01背包问题中，那么把它看成泛化物品，它就是除了h(c) = w其他函数值都为0 的一个函数( 要么取h(c)要么不取h(0))
    .如果是完全背包问题中的物品，那么他可以看成这样一个函数，仅当v被c整除时有h(v) = v/c * w,其它函数值均为0(v/c指价值为c的物品取了v/c个)
    其他的都为0.如果是多重背包问题中重复次数最多为n的物品，那么他的泛化物品的函数有h(v)=v/c*w仅当v被c整除且v/c&lt;=n，其它情况函数值均为0。

    一个物品组可以看做一个繁华物品h。对于一个0..V中的v，若干物品组中不存在费用为v的物品，则h(v) = 0，否则h(v)是多有费用为v的物品的最大价值。
    依赖问题中的没个主件和附件集合等价于一个物品组，也可以看作为一个泛化物品。

    泛化物品的和：
    如果面对两个泛化物品h和l，要用给定的费用从这两个泛化物品中得到最大的价值，事实上对于一个给定的费用v，只需要枚举将这个费用如何分配给两个
    泛化物品就可以了。同样的，对于0..V的每一个整数v，可以求得费用v分配到h和l中的最大价值dp[v],也就是dp[v] = max( h(k)+l(v-k) | 0&lt;=k&lt;=v).可以看出dp
    夜视仪有繁华物品h和l决定的定义域为0..V的函数，=&gt;dp是一个有泛化物h和l决定的泛化物品。由此可定义泛化物品的和：h、l都是泛化物品，若泛化物品dp满足
    dp(v)=max(h(k)+l(v-k)|0&lt;=k&lt;=v)，则称dp是h与l的和，即dp=h+l。这个运算的时间复杂度是O(V^2)。 

    背包问题的泛化物品：
    一个背包问题中，可能会给出很多条件，包括每种物品的费用、价值的属性，物品之间的分组、依赖等关系。但肯定能将问题对应于某个泛化物品。也就是说，
    给定了所有条件后，就可以对每个非负整数v求得：若背包容量为V，将物品装入背包可得到的最大价值是多少，这可以认为是定义在非负整数机上的一键泛化物品。
    这个泛化物品——或者说问题所对应的一个定义域为非负整数的函数——包含了关于问题本身的高度浓缩的信息。一般而言，求得这个泛化物品的一个子域（例如0..V）
    的值之后，就可以根据这个函数的取值得到背包问题的最终答案。
</code></pre><h2 id="18-8-背包问题的变化"><a href="#18-8-背包问题的变化" class="headerlink" title="18.8 背包问题的变化"></a>18.8 背包问题的变化</h2><h3 id="18-8-1-求解最多可以放多少件物品或者最多可以装满多少背包的空间。这都可以根据具体问题利用前面的方程求出所有状态的值（dp数组）之后得到。"><a href="#18-8-1-求解最多可以放多少件物品或者最多可以装满多少背包的空间。这都可以根据具体问题利用前面的方程求出所有状态的值（dp数组）之后得到。" class="headerlink" title="18.8.1 求解最多可以放多少件物品或者最多可以装满多少背包的空间。这都可以根据具体问题利用前面的方程求出所有状态的值（dp数组）之后得到。"></a>18.8.1 求解最多可以放多少件物品或者最多可以装满多少背包的空间。这都可以根据具体问题利用前面的方程求出所有状态的值（dp数组）之后得到。</h3><h3 id="18-8-2-如果要求的是“总价值最小”“总件数最小”，只需简单的将上面的状态转移方程中的max改成min即可。"><a href="#18-8-2-如果要求的是“总价值最小”“总件数最小”，只需简单的将上面的状态转移方程中的max改成min即可。" class="headerlink" title="18.8.2 如果要求的是“总价值最小”“总件数最小”，只需简单的将上面的状态转移方程中的max改成min即可。"></a>18.8.2 如果要求的是“总价值最小”“总件数最小”，只需简单的将上面的状态转移方程中的max改成min即可。</h3><h3 id="18-8-3-输出方案"><a href="#18-8-3-输出方案" class="headerlink" title="18.8.3 输出方案"></a>18.8.3 输出方案</h3><pre><code>一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方
程的哪一项推出来的，换句话说，记录下它是由哪一个策略推出来的。便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。
以01背包为例，方程为dp[i][v]=max{dp[i-1][v],dp[i-1][v-c[i]]+w[i]}。再用一个数组g[i] [v]，设g[i][v]=0表示推出dp[i][v]的值时是采用了方程的前一项（
也即dp[i][v]=dp[i-1][v]），g[i][v]表示采用了方程的后一项。注意这两项分别表示了两种策略：未选第i个物品及选了第i个物品。那么输出方案的伪代码可以
这样写（设最终状态为dp[N][V]）：
    v = V
    for i = N..0
        if ( g[i][v] == 0) cout &lt;&lt; &quot;未选第i件&quot;
        else if ( g[i][v] == 1)  cout &lt;&lt; &quot;选第i件&quot;
                                 v = v - c[i]
另外，采用方程的前一项或后一项也可以在输出方案的过程中根据dp[i][v]的值实时地求出来，也即不须纪录g数组，将上述代码中的g[i] [v]==0改成dp[i][v]==dp[i-1][v]
，g[i][v]==1改成dp[i][v]==dp[i-1][v-c[i]]+w[i]也可。
</code></pre><h3 id="18-8-4-输出字典序最小的最优方案"><a href="#18-8-4-输出字典序最小的最优方案" class="headerlink" title="18.8.4 输出字典序最小的最优方案"></a>18.8.4 输出字典序最小的最优方案</h3><pre><code>这里“字典序最小”的意思是1..N号物品的选择方案排列出来以后字典序最小。以输出01背包最小字典序的方案为例。 
只需要在转移时注意策略。首先，子问题的定义要略改一些。我们注意到，如果存在一个选了物品1的最优方案，那么答案一定包含物品1，原问题转化为一个背包
容量为v-c[1]，物品为2..N的子问题。反之，如果答案不包含物品1，则转化成背包容量仍为V，物品为2..N的子问题。不管答案怎样，子问题的物品都是以i..N而
非前所述的1..i的形式来定义的，所以状态的定义和转移方程都需要改一下。但也许更简易的方法是先把物品逆序排列一下，以下按物品已被逆序排列来叙述。 

从N到1输入时，如果dp[i][v] == dp[i-1][v]及dp[i][v] == dp[i-1][v-c[i]]+w[i]同时成立，应该按照选择了物品i的方案输出
</code></pre><h3 id="18-8-5-求方案总数"><a href="#18-8-5-求方案总数" class="headerlink" title="18.8.5 求方案总数"></a>18.8.5 求方案总数</h3><pre><code>对于这类改变问法的问题，一般只需将状态转移方程中的max改成sum即可。例如若每件物品均是01背包中的物品，转移方程即为dp[i][v]=sum(dp[i-1][v],dp[i-1][v-c[i]]+w[i])，初始条件dp[0][0]=1。 
</code></pre><h3 id="18-8-6-最优方案总数"><a href="#18-8-6-最优方案总数" class="headerlink" title="18.8.6 最优方案总数"></a>18.8.6 最优方案总数</h3><pre><code>最优方案是指物品总价值最大的方案。还是以01背包为例。 
结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：dp[i][v]意义同前述，g[i][v]表示这个子问题的最优方案的总数，则在求dp[i][v]的同时求g[i][v]的伪代码如下： 

for i=1..N 
    for v=0..V 
        dp[i][v]=max(dp[i-1][v],dp[i-1][v-c[i]]+w[i])
        g[i][v]=0 
        if(dp[i][v]==dp[i-1][v]) 
            inc(g[i][v],g[i-1][v])
        if(dp[i][v]==dp[i-1][v-c[i]]+w[i]) 
            inc(g[i][v],g[i-1][v-c[i]]) 
</code></pre><h1 id="19、-Leetcode-375-Guess-Number-Higher-or-Lower-II"><a href="#19、-Leetcode-375-Guess-Number-Higher-or-Lower-II" class="headerlink" title="19、 Leetcode 375. Guess Number Higher or Lower II"></a>19、 Leetcode 375. Guess Number Higher or Lower II</h1><ul>
<li>问题:<ul>
<li>给定一个数n,然后你从1..n猜取一个数x，猜错的y会被当做花费叠加到sum里,如果y &lt; x 会告知小了，反之告知大了，求要保证猜到n的任何一个数，所需要的最小花费。</li>
</ul>
</li>
<li>思路:<ul>
<li>假设在[start, end]的范围内取x错了，那么dp[start][end]的一个待取项为x + max( dp[start][x-1], dp[x+1][end]),然后x可以是从start到end任意一项，然后dp[start][end] = min( x + max( dp[start][x-1], dp[x+1][end])) (x从strat取到end)<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt; <span class="keyword">int</span>&gt; &gt; dp( n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;( n+<span class="number">1</span>, INT_MAX));</div><div class="line">    <span class="keyword">return</span> dpAlgorithm( dp, <span class="number">1</span>, n);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dpAlgorithm</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp;dp, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>( start &gt;= end ) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>( dp[start][end] != INT_MAX) <span class="keyword">return</span> dp[start][end];</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> x = start; x &lt;= end; ++x)&#123;</div><div class="line">        dp[start][end] = min( dp[start][end], x + max( dpAlgorithm( dp, start, x<span class="number">-1</span>), dpAlgorithm( dp, x+<span class="number">1</span>, end)));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[start][end];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="20、Leetcode-300-Longest-Increasing-Subsequence"><a href="#20、Leetcode-300-Longest-Increasing-Subsequence" class="headerlink" title="20、Leetcode 300. Longest Increasing Subsequence"></a>20、Leetcode 300. Longest Increasing Subsequence</h1><ul>
<li>问题:<ul>
<li>给定一个数组，找出该数组的最长的递增子串的长度</li>
</ul>
</li>
<li>思路:<ul>
<li>假设dp[i]是前i个的最长递增子串长度，<br>dp[i] = max( dp[j]+1, dp[i]) (i&lt;j&lt;=end)</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp( nums.size(), <span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.size(); ++j)&#123;</div><div class="line">            <span class="keyword">if</span>( nums[j] &gt; nums[i])&#123;</div><div class="line">                dp[j] = max( dp[j], dp[i] + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> *max_element( dp.begin(), dp.end());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="21、Leetcode-376-Wiggle-Subsequence"><a href="#21、Leetcode-376-Wiggle-Subsequence" class="headerlink" title="21、Leetcode 376. Wiggle Subsequence"></a>21、Leetcode 376. Wiggle Subsequence</h1><ul>
<li>问题：<ul>
<li>如果连续数字之间的差异在正和负之间严格交替，则数字序列称为摆动序列。 第一个差异（如果存在）可能是正或负。 具有少于两个元素的序列通常是摆动序列。 例如，[1,7,4,9,2,5]是摆动序列，因为差异（6，-3,5，-7,3）交替是正的和负的。 相比之下，[1,4,7,2,5]和[1,7,4,5,5]不是摆动序列，第一个因为它的前两个差异是正的，而第二个差异是最后一个差值为零。 给定整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些数量的元素（最终也为零）获得子序列，将剩余的元素保留为其原始顺序。</li>
</ul>
</li>
<li>思路：<ul>
<li>由于摆动序列是增减交替的所以我们需要两个数组来分别存储上一次是增或则减的时候的最大长度，当i相对于i-1是增的时候increasing[i] = releasing[i-1] + 1;releasing[i] = releasing[i-1];<br>当i相对于i-1是减的时候releasing[i] = increasing[i-1] + 1;increasing[i] = increasing[i-1];</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = nums.size();</div><div class="line">    <span class="keyword">if</span>( n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; increasing( n, <span class="number">0</span>);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; releasing( n, <span class="number">0</span>);</div><div class="line">    increasing[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    releasing[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</div><div class="line">        <span class="keyword">if</span>( nums[i] &gt; nums[i+<span class="number">1</span>])&#123;</div><div class="line">            increasing[i+<span class="number">1</span>] = increasing[i];</div><div class="line">            releasing[i+<span class="number">1</span>] = increasing[i] + <span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[i] &lt; nums[i+<span class="number">1</span>])&#123;</div><div class="line">            increasing[i+<span class="number">1</span>] = releasing[i] + <span class="number">1</span>;</div><div class="line">            releasing[i+<span class="number">1</span>] = releasing[i];</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            increasing[i+<span class="number">1</span>] = increasing[i];</div><div class="line">            releasing[i+<span class="number">1</span>] = releasing[i] ;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max( increasing[n<span class="number">-1</span>], releasing[n<span class="number">-1</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="22、Leetcode-576-Out-of-Boundary-Paths"><a href="#22、Leetcode-576-Out-of-Boundary-Paths" class="headerlink" title="22、Leetcode 576. Out of Boundary Paths"></a>22、Leetcode 576. Out of Boundary Paths</h1><ul>
<li>说明：<ul>
<li>给定一个数组的m和n，步数N，起始位置x，y求有多少种走法可以在N步之内，走到数组的边界外面<br><img src="https://github.com/muyinsuifeng/myleetcode/raw/master/image/out_of_boundary_paths_2.png" alt="out_of_boundary_paths_2" title="Optional title"><!--  ![out_of_boundary_paths_2](./image/out_of_boundary_paths_2.png "Optional title") --></li>
</ul>
</li>
<li><p>思路：</p>
<ul>
<li><p>dp[0][0 … m -1][0 … n - 1] is 0. means the step is 0, all value is 0.<br>Current value only comes from four directions of last move or 1 if it is boundary</p>
</li>
<li><p>dp[step][row][col] = dp[step - 1][row - 1][col] + dp[step - 1][row + 1][col] + dp[step - 1][row][col - 1] + dp[step - 1][row][col + 1]</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> N, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> limit = <span class="number">1000000007</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; &gt; &gt; dp(N+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; &gt;( m, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;( n, <span class="number">0</span>) ) );</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; ++k)</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</div><div class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</div><div class="line">                dp[k][i][j] += (i == <span class="number">0</span>? <span class="number">1</span> :dp[k<span class="number">-1</span>][i<span class="number">-1</span>][j]);</div><div class="line">                dp[k][i][j] += (i == m<span class="number">-1</span>? <span class="number">1</span> :dp[k<span class="number">-1</span>][i+<span class="number">1</span>][j]);</div><div class="line">                dp[k][i][j] += (j == <span class="number">0</span>? <span class="number">1</span> :dp[k<span class="number">-1</span>][i][j<span class="number">-1</span>]);</div><div class="line">                dp[k][i][j] += (j == n<span class="number">-1</span>? <span class="number">1</span> :dp[k<span class="number">-1</span>][i][j+<span class="number">1</span>]);</div><div class="line">                dp[k][i][j] %= limit;</div><div class="line">                <span class="comment">// cout &lt;&lt; "dp["&lt;&lt;k&lt;&lt;"]["&lt;&lt;i&lt;&lt;"]["&lt;&lt;j&lt;&lt;"] = " &lt;&lt; dp[k][i][j] &lt;&lt; endl;</span></div><div class="line">            &#125;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)dp[N][x][y];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> DP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DFS-algorithm]]></title>
      <url>/2017/08/24/DFS-algorithm/</url>
      <content type="html"><![CDATA[<h1 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h1><pre><code>题目
输入一个bool矩阵 1表示可以通行 0表示不可通行，然后输入(bx, by) 和 (ex, ey)表示起点和终点坐标，输出所有可能的路径
</code></pre><a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dx(&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;);</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dy(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;);</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; &amp;v, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; &amp;ischoose, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;way, <span class="keyword">int</span> dep, <span class="keyword">int</span> bx, <span class="keyword">int</span> by, <span class="keyword">int</span> ex, <span class="keyword">int</span> ey, <span class="keyword">int</span> &amp;count)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>( bx == ex &amp;&amp; by == ey)&#123;</div><div class="line">        count++;</div><div class="line">        <span class="comment">// for( int i = 0; i &lt; dep; ++i)</span></div><div class="line">            <span class="comment">// cout &lt;&lt; "(" &lt;&lt; way[i][0] &lt;&lt; "," &lt;&lt; way[i][1] &lt;&lt; ")" ;</span></div><div class="line">        <span class="comment">// cout &lt;&lt; endl;</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</div><div class="line">            <span class="keyword">int</span> tx = bx + dx[i];</div><div class="line">            <span class="keyword">int</span> ty = by + dy[i];</div><div class="line">            <span class="keyword">if</span>(  ( tx &lt; v.size() &amp;&amp; tx &gt;= <span class="number">0</span> &amp;&amp; ty &lt; v[<span class="number">0</span>].size() &amp;&amp; ty &gt;= <span class="number">0</span> ) &amp;&amp; v[tx][ty] &amp;&amp;!ischoose[tx][ty])&#123;</div><div class="line">                way[dep][<span class="number">0</span>] = tx;</div><div class="line">                way[dep][<span class="number">1</span>] = ty;</div><div class="line">                ischoose[tx][ty] = <span class="literal">true</span>;</div><div class="line">                search( v, ischoose, way, dep+<span class="number">1</span>, tx, ty, ex, ey, count);</div><div class="line">                ischoose[tx][ty] = <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="comment">// std::vector&lt;std::vector&lt;bool&gt; &gt; v(&#123;&#123;1,0,0,1,0,1&#125;,&#123;1,1,1,1,1,1&#125;,&#123;0,0,1,1,1,0&#125;,&#123;1,1,1,1,1,0&#125;,&#123;1,1,1,0,1,1&#125;&#125;);  </span></div><div class="line">    <span class="comment">// </span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; v(&#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;&#125;); </div><div class="line">    <span class="keyword">int</span> bx = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> by = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> ex = <span class="number">4</span>;</div><div class="line">    <span class="keyword">int</span> ey = <span class="number">5</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; ischoose( <span class="number">5</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; (<span class="number">6</span>, <span class="literal">false</span>));</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; way( <span class="number">30</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>));</div><div class="line">    way[<span class="number">0</span>][<span class="number">0</span>] = bx;</div><div class="line">    way[<span class="number">0</span>][<span class="number">1</span>] = by;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    search( v, ischoose, way, <span class="number">1</span>, bx, by, ex, ey, count);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="2、六角填数问题"><a href="#2、六角填数问题" class="headerlink" title="2、六角填数问题"></a>2、六角填数问题</h1><pre><code>题目
给你1-12，共12个数，其中1,8,3已经填好了，要使横线上和斜线上的4个数的和都相等，y要填啥
         1
8     x      x     x
   y            x
x     x      x     x  
         3
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b( <span class="number">6</span>, <span class="number">0</span>);</div><div class="line">    b[<span class="number">0</span>]=a[<span class="number">1</span>]+a[<span class="number">3</span>]+a[<span class="number">6</span>]+a[<span class="number">8</span>];   </div><div class="line">    b[<span class="number">1</span>]=a[<span class="number">1</span>]+a[<span class="number">4</span>]+a[<span class="number">7</span>]+a[<span class="number">11</span>];  </div><div class="line">    b[<span class="number">2</span>]=a[<span class="number">2</span>]+a[<span class="number">3</span>]+a[<span class="number">4</span>]+a[<span class="number">5</span>];  </div><div class="line">    b[<span class="number">3</span>]=a[<span class="number">2</span>]+a[<span class="number">6</span>]+a[<span class="number">9</span>]+a[<span class="number">12</span>];  </div><div class="line">    b[<span class="number">4</span>]=a[<span class="number">5</span>]+a[<span class="number">7</span>]+a[<span class="number">10</span>]+a[<span class="number">12</span>];  </div><div class="line">    b[<span class="number">5</span>]=a[<span class="number">8</span>]+a[<span class="number">9</span>]+a[<span class="number">10</span>]+a[<span class="number">11</span>]; </div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; ++i)</div><div class="line">        <span class="keyword">if</span>( b[i] != b[i<span class="number">-1</span>]) </div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">      </div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;isuse, <span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>( x == <span class="number">1</span>||x == <span class="number">2</span>||x == <span class="number">12</span>)&#123;</div><div class="line">        dfs( a, isuse, x+<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">if</span>( x == <span class="number">13</span>)&#123;</div><div class="line">            <span class="keyword">if</span>( judge( a))&#123;</div><div class="line">                <span class="keyword">for</span>( <span class="keyword">auto</span> i : a)</div><div class="line">                    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; ends;</div><div class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">                <span class="built_in">cout</span> &lt;&lt; a[<span class="number">6</span>] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">13</span>; ++i)</div><div class="line">            <span class="keyword">if</span>( !isuse[i])&#123;</div><div class="line">                isuse[i] = <span class="literal">true</span>;</div><div class="line">                a[x] = i;</div><div class="line">                dfs( a, isuse, x+<span class="number">1</span>);</div><div class="line">                isuse[i] = <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a( <span class="number">13</span>, <span class="number">0</span>);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; isuse( <span class="number">13</span>, <span class="literal">false</span>);</div><div class="line">    isuse[<span class="number">1</span>] = <span class="literal">true</span>;</div><div class="line">    isuse[<span class="number">8</span>] = <span class="literal">true</span>;</div><div class="line">    isuse[<span class="number">3</span>] = <span class="literal">true</span>;</div><div class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">    a[<span class="number">2</span>] = <span class="number">8</span>;</div><div class="line">    a[<span class="number">12</span>] = <span class="number">3</span>;</div><div class="line">    dfs( a, isuse, <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="3、-N皇后问题"><a href="#3、-N皇后问题" class="headerlink" title="3、 N皇后问题"></a>3、 N皇后问题</h1><pre><code>题目
在N*N格的国际象棋上摆放N个皇后，使其不能互相攻击，
即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。

思路：  1) 算法开始, 清空棋盘，当前行设为第一行，当前列设为第一列
        2) 在当前行，当前列的位置上判断是否满足条件(即保证经过这一点的行,列与斜线上都没有两个皇后)，若不满足，跳到第4步
        3) 在当前位置上满足条件的情形：
             在当前位置放一个皇后，若当前行是最后一行，记录一个解；
             若当前行不是最后一行，当前行设为下一行, 当前列设为当前行的第一个待测位置；
             若当前行是最后一行，当前列不是最后一列，当前列设为下一列；
             若当前行是最后一行，当前列是最后一列，回溯，即清空当前行及以下各行的棋盘，然后，当前行设为上一行，当前列设为当前行的下一个待测位置；
            以上返回到第2步
        4) 在当前位置上不满足条件的情形：
            若当前列不是最后一列，当前列设为下一列，返回到第2步;
            若当前列是最后一列了，回溯，即，若当前行已经是第一行了，算法退出，否则，清空当前行及以下各行的棋盘，然后，当前行设为上一行，当前列设为当前行的下一个待测位置，返回到第2步; 
</code></pre><h2 id="3-1、递归实现"><a href="#3-1、递归实现" class="headerlink" title="3.1、递归实现"></a>3.1、递归实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//伪代码</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">queen</span><span class="params">( <span class="keyword">int</span> row)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>( row == n) print_result();</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">            <span class="keyword">if</span>( can_place(row, k))&#123;</div><div class="line">                place(row, k);</div><div class="line">                queen( row+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queenRow, <span class="keyword">int</span> count)</span></span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"the "</span> &lt;&lt; count &lt;&lt; <span class="string">"th answer:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queenRow.size(); ++i)&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; queenRow.size(); ++j)&#123;</div><div class="line">            <span class="keyword">if</span>( queenRow[i] != j)</div><div class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"x "</span>;</div><div class="line">            <span class="keyword">else</span> </div><div class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Q "</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; queenRow, <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k)&#123;</div><div class="line">        <span class="keyword">if</span>( queenRow[k] == j || <span class="built_in">abs</span>( k - i) == <span class="built_in">abs</span>( queenRow[k] - j))</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">place</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queenRow, <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span>&amp; count)</span></span>&#123;<span class="comment">//放置皇后到棋盘上</span></div><div class="line">    <span class="keyword">if</span>( k &gt;= n)&#123;</div><div class="line">        count ++;</div><div class="line">        <span class="comment">// for( auto i : queenRow)</span></div><div class="line">        <span class="comment">//  cout &lt;&lt; i &lt;&lt; ends;</span></div><div class="line">        <span class="comment">// cout &lt;&lt; endl;</span></div><div class="line">        print( queenRow, count);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123; </div><div class="line">            <span class="comment">// cout &lt;&lt; "here" &lt;&lt; endl;</span></div><div class="line">            <span class="keyword">if</span>( find( queenRow, k, i))&#123;<span class="comment">// k行i列看是否可以放Q</span></div><div class="line">                <span class="comment">// cout &lt;&lt; "here1 " &lt;&lt; i &lt;&lt; endl;</span></div><div class="line">                queenRow[k] = i;</div><div class="line">                place( queenRow, k+<span class="number">1</span>, n, count);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// cout &lt;&lt; "here2" &lt;&lt; endl;</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> N =<span class="number">8</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; queenRow( N, <span class="number">-1</span>);<span class="comment">//记录各个皇后所在的行号</span></div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录解的个数</span></div><div class="line">    place( queenRow,<span class="number">0</span>, N, count);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>这种方法效率一般都比较差，下面讨论一下非递归实现
</code></pre><h2 id="3-2、回溯法"><a href="#3-2、回溯法" class="headerlink" title="3.2、回溯法"></a>3.2、回溯法</h2><pre><code>这种非递归算法，最重要的问题就是在何时回溯以及如何回溯
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q.size(); ++i)&#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; q.size(); ++j)&#123;</div><div class="line">            <span class="keyword">if</span>( q[i] == j) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Q "</span>;</div><div class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"x "</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)</div><div class="line">        <span class="keyword">if</span>( q[i] == col||<span class="built_in">abs</span>(i - row) == <span class="built_in">abs</span>(q[i] - col))</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">queen</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;q, <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>( i &lt; n)&#123;</div><div class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; endl;</span></div><div class="line">        <span class="keyword">while</span>( j &lt; n)&#123;<span class="comment">//对i行的每一列进行探测，看能否放置皇后</span></div><div class="line">            <span class="keyword">if</span>( valid( q, i, j))&#123;<span class="comment">//该位置可以放置</span></div><div class="line">                q[i] = j;<span class="comment">//第i行放置皇后</span></div><div class="line">                j = <span class="number">0</span>;<span class="comment">//第i行放置皇后以后，需要继续探测下一行的皇后位置，所以此处将j清零，从下一行的第0列开始逐列探测  </span></div><div class="line">                <span class="comment">// print(q);</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;<span class="keyword">else</span></div><div class="line">                ++j;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// cout &lt;&lt; "q[" &lt;&lt; i &lt;&lt; "]:" &lt;&lt; q[i] &lt;&lt; endl;</span></div><div class="line">        <span class="keyword">if</span>( q[i] == <span class="number">-1</span>)&#123;<span class="comment">//第i行没有找到可以放置皇后的位置  </span></div><div class="line">            <span class="keyword">if</span>( i == <span class="number">0</span>)<span class="comment">//回溯到第一行，仍然无法找到可以放置皇后的位置，则说明已经找到所有的解，程序终止  </span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">else</span>&#123;<span class="comment">//没有找到可以放置皇后的列，此时就应该回溯  </span></div><div class="line">                i--;</div><div class="line">                j = q[i] + <span class="number">1</span>;<span class="comment">//把上一行皇后的位置往后移一列  </span></div><div class="line">                q[i] = <span class="number">-1</span>;<span class="comment">//把上一行皇后的位置清除，重新探测  </span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( i == n <span class="number">-1</span>)&#123;<span class="comment">//最后一行找到了一个皇后位置，说明找到一个结果，打印出来  </span></div><div class="line">            count++;</div><div class="line">            <span class="comment">// for( auto k : q)</span></div><div class="line">            <span class="comment">//  cout &lt;&lt; k &lt;&lt; ends;</span></div><div class="line">            <span class="comment">// cout &lt;&lt; endl;</span></div><div class="line">            <span class="comment">// cout &lt;&lt; "the " &lt;&lt; count &lt;&lt; "th answer:" &lt;&lt; endl;</span></div><div class="line">            print(q); <span class="comment">//不能在此处结束程序，因为我们要找的是N皇后问题的所有解，此时应该清除该行的皇后，从当前放置皇后列数的下一列继续探测。</span></div><div class="line">            j = q[i] + <span class="number">1</span>;<span class="comment">//从最后一行放置皇后列数的下一列继续探测</span></div><div class="line">            q[i] = <span class="number">-1</span>;<span class="comment">//清除最后一行的皇后位置</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        ++i;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> N = <span class="number">10</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q( N, <span class="number">-1</span>);</div><div class="line">    queen( q, N);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-3、-用位运算来求解N皇后问题-也是目前最快的N皇后解决算法"><a href="#3-3、-用位运算来求解N皇后问题-也是目前最快的N皇后解决算法" class="headerlink" title="3.3、 用位运算来求解N皇后问题(也是目前最快的N皇后解决算法)"></a>3.3、 用位运算来求解N皇后问题(也是目前最快的N皇后解决算法)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//其中核心的代码，也就是判断能否放置Q的代码如下</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">( <span class="keyword">int</span> row, <span class="keyword">int</span> ld, <span class="keyword">int</span> rd)</span></span>&#123;<span class="comment">//row ld rd分别表示在纵列，和俩个对角线方向的限制下，在一行哪些地方不能放，冲突的位置放1</span></div><div class="line">                                            <span class="comment">//把这三个条件并起来取反就得到了这一行可以放置的位置pos</span></div><div class="line">        <span class="keyword">int</span> pos, p;</div><div class="line">        <span class="keyword">if</span>( row != upperlim)&#123;</div><div class="line">            pos = upperlim &amp; (~(row| ld| rd));</div><div class="line">            <span class="keyword">while</span>( pos)&#123;</div><div class="line">                p = pos &amp; ( ~pos + <span class="number">1</span>);</div><div class="line">                pos = pos - p;</div><div class="line">                test( row|p, (ld|p) &lt;&lt; <span class="number">1</span>, (rd|p) &gt;&gt; <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span></div><div class="line">            ++Ans;</div><div class="line">    &#125;</div><div class="line">    upperlim = (<span class="number">1</span> &lt;&lt; n ) - <span class="number">1</span>;</div><div class="line">    Ans = <span class="number">0</span>;</div></pre></td></tr></table></figure>
<pre><code>/*
** 目前最快的N皇后递归解决方法
** N Queens Problem
** 试探-回溯算法，递归实现
*/
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">// sum用来记录皇后放置成功的不同布局数；upperlim用来标记所有列都已经放置好了皇后。</span></div><div class="line"><span class="keyword">long</span> sum = <span class="number">0</span>, upperlim = <span class="number">1</span>;     </div><div class="line"></div><div class="line"><span class="comment">// 试探算法从最右边的列开始。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">long</span> row, <span class="keyword">long</span> ld, <span class="keyword">long</span> rd)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (row != upperlim)&#123;<span class="comment">//upperlim 为1111111111...就是判断这一行是否还有可以放的位置</span></div><div class="line">        <span class="comment">// row，ld，rd进行“或”运算，求得所有可以放置皇后的列,对应位为0，</span></div><div class="line">        <span class="comment">// 然后再取反后“与”上全1的数，来求得当前所有可以放置皇后的位置，对应列改为1</span></div><div class="line">        <span class="comment">// 也就是求取当前哪些列可以放置皇后</span></div><div class="line">        <span class="keyword">long</span> pos = upperlim &amp; ~(row | ld | rd); </div><div class="line">        <span class="keyword">while</span> (pos)&#123;    <span class="comment">// 0 -- 皇后没有地方可放，回溯</span></div><div class="line"></div><div class="line">            <span class="comment">// 拷贝pos最右边为1的bit，其余bit置0</span></div><div class="line">            <span class="comment">// 也就是取得可以放皇后的最右边的列</span></div><div class="line">            <span class="keyword">long</span> p = pos &amp; -pos; <span class="comment">//p = pos &amp; (~pos+1);                                             </span></div><div class="line"></div><div class="line">            <span class="comment">// 将pos最右边为1的bit清零</span></div><div class="line">            <span class="comment">// 也就是为获取下一次的最右可用列使用做准备，</span></div><div class="line">            <span class="comment">// 程序将来会回溯到这个位置继续试探</span></div><div class="line">            pos -= p;                           </div><div class="line"></div><div class="line">            <span class="comment">// row + p，将当前列置1，表示记录这次皇后放置的列。</span></div><div class="line">            <span class="comment">// (ld + p) &lt;&lt; 1，标记当前皇后左边相邻的列不允许下一个皇后放置。</span></div><div class="line">            <span class="comment">// (ld + p) &gt;&gt; 1，标记当前皇后右边相邻的列不允许下一个皇后放置。</span></div><div class="line">            <span class="comment">// 此处的移位操作实际上是记录对角线上的限制，只是因为问题都化归</span></div><div class="line">            <span class="comment">// 到一行网格上来解决，所以表示为列的限制就可以了。显然，随着移位</span></div><div class="line">            <span class="comment">// 在每次选择列之前进行，原来N×N网格中某个已放置的皇后针对其对角线</span></div><div class="line">            <span class="comment">// 上产生的限制都被记录下来了</span></div><div class="line">            test(row + p, (ld + p) &lt;&lt; <span class="number">1</span>, (rd + p) &gt;&gt; <span class="number">1</span>);                              </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>   </div><div class="line">        <span class="comment">// row的所有位都为1，即找到了一个成功的布局，回溯</span></div><div class="line">        sum++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n = <span class="number">16</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 因为整型数的限制，最大只能32位，</span></div><div class="line">    <span class="comment">// 如果想处理N大于32的皇后问题，需要</span></div><div class="line">    <span class="comment">// 用bitset数据结构进行存储</span></div><div class="line">    <span class="keyword">if</span> ((n &lt; <span class="number">1</span>) || (n &gt; <span class="number">32</span>)) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" n just between 1 and 32\n"</span> &lt;&lt; <span class="built_in">endl</span>;;</div><div class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" queen"</span> &lt;&lt; <span class="built_in">endl</span>;;</div><div class="line"></div><div class="line">    <span class="comment">// N个皇后只需N位存储，N列中某列有皇后则对应bit置1。</span></div><div class="line">    upperlim = (upperlim &lt;&lt; n) - <span class="number">1</span>;         </div><div class="line"></div><div class="line">    test(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[classical-algorithm]]></title>
      <url>/2017/08/24/classical-algorithm/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/libra-yong/p/6390303.html" target="_blank" rel="external">经典算法问题http://www.cnblogs.com/libra-yong/p/6390303.html</a></p>
<h1 id="1、三色旗问题"><a href="#1、三色旗问题" class="headerlink" title="1、三色旗问题"></a>1、三色旗问题</h1><a id="more"></a>
<ul>
<li>问题：<ul>
<li>假设有一条绳子，上面有红，白，蓝三种颜色的旗子，起初绳子上的旗子颜色并没有顺序，您希望将之分类，并排列为蓝，白，红的顺序，要如何移动次数才会最少，注意您只能在绳子上进行这份动作，而且一次只能调换两个色旗子。</li>
</ul>
</li>
<li>解法：<ul>
<li>在一条绳子上移动，在程式中也就意味着只能使用一个阵列，而不能使用其他的阵列来作辅助，问题的解法很简单您可以自己想像一下在移动旗子，从绳子开头进行，遇到蓝色往前移，遇到白色留在中间，遇到红色往后移，如下所示：<br>只是要让移动的次数最少的话， 就要有些技巧：<br> 1.如果图中W所在位置为白色，则W+1, 表示未处理的部分移至白色群组。<br> 2.如果W部分为蓝色， 则B与W的元素对调，而B与W必须各 +1， 表示两个群组都多了一个元素。<br> 2.如果W所在的位置是红色，则将W与R交换，但R要减 1，表示未处理的部分减 1.</li>
</ul>
</li>
<li>注意：<ul>
<li>B，W，R并不是三色旗的个数，它们只是一个移动的指标；什么时候移动结束呢？一开始时未处理的R指标会是等于旗子的总数，当R的索引数减至少于W的索引数时，表示接下来的旗子就是红色了，此时就可以结束移动</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">threeColorFlag</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v, <span class="keyword">int</span> b, <span class="keyword">int</span> w, <span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//b,w表示blue和white的末尾index,r表示red的头index</span></div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>( w &lt; r) &#123;</div><div class="line">        <span class="keyword">if</span>( v[w] == w)</div><div class="line">            w++;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( v[w] == b)&#123;</div><div class="line">            swap( v[w], v[b]);</div><div class="line">            b++;</div><div class="line">            w++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">while</span>( w &lt; r &amp;&amp; v[r] == r)</div><div class="line">                r--;</div><div class="line">            swap( v[w], v[r]);</div><div class="line">            r--;</div><div class="line">        &#125;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; count;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v(&#123;<span class="string">'r'</span>, <span class="string">'w'</span>, <span class="string">'b'</span>, <span class="string">'w'</span>, <span class="string">'w'</span>, <span class="string">'b'</span>, <span class="string">'r'</span>, <span class="string">'b'</span>, <span class="string">'w'</span>, <span class="string">'r'</span>&#125;);</div><div class="line">    threeColorFlag( v, <span class="number">0</span>, <span class="number">0</span>, v.size()<span class="number">-1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"># <span class="number">2</span>、老鼠走迷宫</div><div class="line">- 说明：</div><div class="line">    + 老鼠走迷宫是递回求解的基本题型，我们在二维阵列中使用<span class="number">2</span>表示迷宫墙壁，使用<span class="number">1</span>表示老鼠行走的路径，试以程式求出由入口至出口的路径。</div><div class="line">- 解法：</div><div class="line">    + 老鼠走迷宫是递回求解的基本题型，我们在二维阵列中使用<span class="number">2</span>表示迷宫墙壁，使用<span class="number">1</span>表示老鼠行走的路径，试以程式求出由入口至出口的路径。</div><div class="line"></div><div class="line">```c++</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; offsetx(&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;);</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; offsety(&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;);</div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseRunMaze</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;v, <span class="keyword">int</span> startx, <span class="keyword">int</span> starty, <span class="keyword">int</span> endx, <span class="keyword">int</span> endy)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>( startx == endx&amp;&amp; starty == endy)&#123;</div><div class="line">        count ++;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">"th way"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> i : v)&#123;</div><div class="line">            <span class="keyword">for</span>( <span class="keyword">auto</span> j : i)</div><div class="line">                <span class="built_in">cout</span> &lt;&lt; j &lt;&lt; ends;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        v[startx][starty] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</div><div class="line">            <span class="keyword">int</span> tx = startx + offsetx[i];</div><div class="line">            <span class="keyword">int</span> ty = starty + offsety[i];</div><div class="line">            <span class="keyword">if</span>( tx &gt;= <span class="number">1</span> &amp;&amp; tx &lt; v.size()<span class="number">-1</span>&amp;&amp; ty &gt;= <span class="number">1</span>&amp;&amp; ty &lt; v[<span class="number">0</span>].size()<span class="number">-1</span> &amp;&amp; v[tx][ty] == <span class="number">0</span>)&#123;</div><div class="line">                v[tx][ty] = <span class="number">1</span>;</div><div class="line">                mouseRunMaze( v, tx, ty, <span class="number">5</span>, <span class="number">5</span>);</div><div class="line">                v[tx][ty] = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v(&#123;&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,</div><div class="line">                        &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>&#125;,</div><div class="line">                        &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>&#125;,</div><div class="line">                        &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,</div><div class="line">                        &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,</div><div class="line">                        &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>&#125;,</div><div class="line">                        &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;&#125;);</div><div class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> y = <span class="number">1</span>;</div><div class="line">    mouseRunMaze( v, x, y, <span class="number">5</span>, <span class="number">5</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//output 1th way</span></div><div class="line">&lt;!-- <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span></div><div class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span></div><div class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">2</span></div><div class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span></div><div class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span></div><div class="line"><span class="number">2</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span></div><div class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> --&gt;</div></pre></td></tr></table></figure>
<h1 id="3、骑士走棋盘"><a href="#3、骑士走棋盘" class="headerlink" title="3、骑士走棋盘"></a>3、骑士走棋盘</h1><ul>
<li>说明：<ul>
<li>骑士旅游Knight tour在十八世纪初倍受数学家与拼图迷的注意，它什么时候被提出已不可考，骑士的走法为西洋棋的走法，骑士可以由任一个位置出发，它要如何走完所有的位置。</li>
<li><!-- ![KnightRunChess](./image/knightRunChess.gif "KnightRunChess") -->
<img src="https://github.com/muyinsuifeng/myleetcode/raw/master/image/knightRunChess.gif" alt="KnightRunChess" title="KnightRunChess"></li>
</ul>
</li>
<li>解法：<ul>
<li>骑士的走法,基本上可以用递回来解决,但是纯粹的递回在维度大时相当没有效率,一个聪明的解法由J.CWarnsdorff在1823年提出， 简单地说，<strong>先将最难的位置走完，接下来的路就宽广了，骑士所想要的下一步，为下一不再 选择时，所能走的步数最少的一步,骑士在每一步都有8种可能的下一步走法(边界上除外),为了提高效率,可以选择所要走的下一步为下一步要选择时所能走的步数最少的一步</strong>。使用这个方法，在不使用递回的情况下，可以有较高的机率找出走法（找不到走的机率也是有的）  </li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">knightRunChess</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;board, <span class="keyword">int</span> startx, <span class="keyword">int</span> starty)</span>        <span class="comment">//遍历函数,传入数组表示棋盘,x,y表示骑士的初始位置坐标</span></span></div><div class="line"><span class="function"><span class="comment">//具体步骤:</span></span></div><div class="line"><span class="function"><span class="comment">//首先记录当前位置走的次序,然后遍历棋盘,得到可能的下一跳数目,通过min函数找到最合适的下一跳,记录下一跳位置走的次序.如果能够遍历完成,返回true表示骑士不重复的走完棋盘.</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">possibleWay</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nextx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nexty, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><span class="comment">//计算下一步的可能方向,传入数组表示棋盘,数组记录多个下一步可能方向,x,y为当前骑士位置坐标</span></span></div><div class="line"><span class="function"><span class="comment">//具体步骤:</span></span></div><div class="line"><span class="function"><span class="comment">//将所有的下一跳以坐标表示,若当前位置上下一跳的元素值为0表示未走过为一种可能方向,下一跳数组记录下一跳坐标,计数器累加,返回计数器</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDirection</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nextx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nexty)</span>  <span class="comment">//从多个可能方向中找出下一方向数最少的方向</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></div><div class="line"><span class="function"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span></div><div class="line"><span class="function"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">possibleWay</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nextx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nexty, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; offsetx(&#123;<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; offsety(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ().swap(nextx);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ().swap(nexty);</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; offsetx.size(); ++k)&#123;</div><div class="line">        <span class="keyword">int</span> nexti = i + offsetx[k];</div><div class="line">        <span class="keyword">int</span> nextj = j + offsety[k];</div><div class="line">        <span class="keyword">if</span>( nexti &lt; <span class="number">0</span> || nexti &gt; <span class="number">7</span>||nextj &lt; <span class="number">0</span> || nextj &gt; <span class="number">7</span>) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">if</span>( board[nexti][nextj] == <span class="number">0</span>)&#123;</div><div class="line">            nextx.push_back(nexti);</div><div class="line">            nexty.push_back(nextj);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// cout &lt;&lt; "nextx :";</span></div><div class="line">    <span class="comment">// for( auto q : nextx)</span></div><div class="line">    <span class="comment">//  cout &lt;&lt; q &lt;&lt; ends;</span></div><div class="line">    <span class="comment">// cout &lt;&lt; endl;</span></div><div class="line">    <span class="comment">// cout &lt;&lt; "nexty :";</span></div><div class="line">    <span class="comment">// for( auto q : nexty)</span></div><div class="line">    <span class="comment">//  cout &lt;&lt; q &lt;&lt; ends;</span></div><div class="line">    <span class="comment">// cout &lt;&lt; endl;</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDirection</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nextx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nexty)</span></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; offsetx(&#123;<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; offsety(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; stepNumber( nextx.size(), <span class="number">0</span>);<span class="comment">//记录该方向下一跳的数目</span></div><div class="line">    <span class="keyword">int</span> mindirection = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span>( nextx.size() == <span class="number">1</span>) mindirection = <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nextx.size(); ++i)</div><div class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; offsetx.size(); ++j)&#123;</div><div class="line">                <span class="keyword">int</span> tx = nextx[i] + offsetx[j];</div><div class="line">                <span class="keyword">int</span> ty = nexty[i] + offsety[j];</div><div class="line">                <span class="keyword">if</span>( tx &lt; <span class="number">0</span> || tx &gt; <span class="number">7</span>|| ty &lt; <span class="number">0</span> || ty &gt; <span class="number">7</span>) <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">if</span>( board[tx][ty] == <span class="number">0</span>)</div><div class="line">                    stepNumber[i] ++;</div><div class="line">            &#125;</div><div class="line">        mindirection = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; stepNumber.size(); ++i)</div><div class="line">            <span class="keyword">if</span>( stepNumber[i] &lt; stepNumber[mindirection] )</div><div class="line">                mindirection = i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> mindirection;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">knightRunChess</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;board, <span class="keyword">int</span> startx, <span class="keyword">int</span> starty)</span></span>&#123;</div><div class="line">    board[startx][starty] = <span class="number">1</span>;<span class="comment">//当前位置为第一次走的位置</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextx;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nexty;<span class="comment">//下一跳容器</span></div><div class="line">    <span class="keyword">int</span> i = startx;</div><div class="line">    <span class="keyword">int</span> j = starty;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= <span class="number">64</span>; ++k)&#123;</div><div class="line">        possibleWay( board, nextx, nexty, i, j);<span class="comment">//计算下一跳可能的数目</span></div><div class="line">        <span class="keyword">if</span>( nextx.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">int</span> mindirection = minDirection( board, nextx, nexty);</div><div class="line">        i = nextx[mindirection];</div><div class="line">        j = nexty[mindirection];</div><div class="line">        board[i][j] = k;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> q : board)&#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> w : q)</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; w &lt;&lt; ends;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;   </div><div class="line">        </div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; board(<span class="number">8</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">8</span>, <span class="number">0</span>));</div><div class="line">    <span class="keyword">int</span> startx = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> starty = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(knightRunChess( board, startx, starty))</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"success"</span>;</div><div class="line">    <span class="keyword">else</span> </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"defeat"</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="4、八枚银币"><a href="#4、八枚银币" class="headerlink" title="4、八枚银币"></a>4、八枚银币</h1><ul>
<li>说明：<ul>
<li>现有八枚银币a, b, c, d, e, f, g, h，已知其中一枚是假币，其重量不同于真币，但不知是较轻或较重，如何使用天平以最少的比较次数，决定出哪枚是假币，并得知假币比真币较轻或较重。</li>
</ul>
</li>
<li>解法：<ul>
<li>单就求假币的问题是不难，但问题限制使用最少的比较次数，所以我们<strong>不能以单纯的回圈比较来求解</strong>，我们可以<strong>使用决策树(deciseion tree)</strong>，使用分析与树状图来协助求解。一个简单的状况是这样的，我们比较a+b+c 与 d+e+f ， 如果相等，则假币必是g或h，我们先比较g或h哪个较重，如果g较重，再与a比较(a是真币)，如果g等于a，则g为真币，则h为假币，由于h币g轻而g是真币，则h假币的重量比真币轻。 </li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> coins[], <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(coins[i] &gt; coins[k])</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n假币 %d 较重"</span>, i + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n假币 %d 较轻"</span>, j + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">eightcoins</span><span class="params">(<span class="keyword">int</span> coins[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(coins[<span class="number">0</span>] + coins[<span class="number">1</span>] + coins[<span class="number">2</span>] == coins[<span class="number">3</span>] + coins[<span class="number">4</span>] + coins[<span class="number">5</span>])</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(coins[<span class="number">6</span>] &gt; coins[<span class="number">7</span>])</div><div class="line">        &#123;</div><div class="line">            compare(coins, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            compare(coins, <span class="number">7</span>, <span class="number">6</span>, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(coins[<span class="number">0</span>] + coins[<span class="number">1</span>] + coins[<span class="number">2</span>] &gt; coins[<span class="number">3</span>] + coins[<span class="number">4</span>] + coins[<span class="number">5</span>])</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(coins[<span class="number">0</span>] + coins[<span class="number">3</span>] == coins[<span class="number">1</span>] + coins[<span class="number">4</span>])</div><div class="line">        &#123;</div><div class="line">            compare(coins, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(coins[<span class="number">0</span>] + coins[<span class="number">3</span>] &gt; coins[<span class="number">1</span>] + coins[<span class="number">4</span>])</div><div class="line">        &#123;</div><div class="line">            compare(coins, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(coins[<span class="number">0</span>] + coins[<span class="number">3</span>] &lt; coins[<span class="number">1</span>] + coins[<span class="number">4</span>])</div><div class="line">        &#123;</div><div class="line">            compare(coins, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(coins[<span class="number">0</span>] + coins[<span class="number">1</span>] + coins[<span class="number">2</span>] &lt; coins[<span class="number">3</span>] + coins[<span class="number">4</span>] + coins[<span class="number">5</span>])</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(coins[<span class="number">0</span>] + coins[<span class="number">3</span>] == coins[<span class="number">1</span>] + coins[<span class="number">4</span>])</div><div class="line">        &#123;</div><div class="line">            compare(coins, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(coins[<span class="number">0</span>] + coins[<span class="number">3</span>] &gt; coins[<span class="number">1</span>] + coins[<span class="number">4</span>])</div><div class="line">        &#123;</div><div class="line">            compare(coins, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(coins[<span class="number">0</span>] + coins[<span class="number">3</span>] &lt; coins[<span class="number">1</span>] + coins[<span class="number">4</span>])</div><div class="line">        &#123;</div><div class="line">            compare(coins, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="5、汉若塔问题"><a href="#5、汉若塔问题" class="headerlink" title="5、汉若塔问题"></a>5、汉若塔问题</h1><h2 id="5-1普通汉若塔问题"><a href="#5-1普通汉若塔问题" class="headerlink" title="5.1普通汉若塔问题"></a>5.1普通汉若塔问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> sources, <span class="keyword">char</span> temp, <span class="keyword">char</span> target)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>( n == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"move the "</span> &lt;&lt; n &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        hanoi( n<span class="number">-1</span>, sources, target, temp);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"move the "</span> &lt;&lt; n &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        hanoi( n<span class="number">-1</span>, temp, temp, target);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n = <span class="number">3</span>;</div><div class="line">    hanoi( n, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5-2-双色汉若塔问题"><a href="#5-2-双色汉若塔问题" class="headerlink" title="5.2 双色汉若塔问题"></a>5.2 双色汉若塔问题</h2><ul>
<li>问题描述：<ul>
<li>就是要把所有的黄色盘子最终都放在第二个柱子上（顺序还是小的在上，大的在下！），而蓝色的盘子全部放在第三根柱子上（从小到大）！这个就要复杂一下啦，其实原理都是一样的！<!-- ![twoColorHannoi](./image/twoColorHannoi.jpg "Optional title") -->
<img src="https://github.com/muyinsuifeng/myleetcode/raw/master/image/twoColorHannoi.jpg" alt="twoColorHannoi" title="Optional title"></li>
</ul>
</li>
<li>解法：<ul>
<li>设盘子原来在A柱上，目标为B、C柱。显然与单色汉诺塔问题相同为典型的递归问题。将最后的盘子移动的目标步骤为：<ul>
<li>(1) 除最后两个盘子外，将所有的盘子移动到C；</li>
<li>(2) 将最后的两个盘子移动到B；</li>
<li>(3) 再将C上所有的盘子移动到A；</li>
<li>(4) 最后将B上的一个盘子移动C。</li>
</ul>
</li>
<li>易得移动出最后两个盘子以外，可以将大小相同颜色不同的盘子看作一个来移动，因此下边提到的个数均代表大小相同颜色不同的盘子。将n个盘子（实际盘子个数位2n）从A移动到C的步骤为：<ul>
<li>(1)  首先将n – 1个盘子从A移动到B;</li>
<li>(2)  将最后的盘子从A移动到C；</li>
<li>(3)  再将B上的盘子移动到C。<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">二色汉诺塔 </span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> sources, <span class="keyword">char</span> temp, <span class="keyword">char</span> target)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>( n == <span class="number">1</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"move the yello "</span> &lt;&lt; n &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"move the blue "</span> &lt;&lt; n &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        hanoi( n<span class="number">-1</span>, sources, target, temp);  </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"move the yello "</span> &lt;&lt; n &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"move the blue "</span> &lt;&lt; n &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        hanoi( n<span class="number">-1</span>, temp, temp, target);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">twoColorHannoi</span><span class="params">( <span class="keyword">int</span> n, <span class="keyword">char</span> sources, <span class="keyword">char</span> temp, <span class="keyword">char</span> target)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>( i = n/<span class="number">2</span>; i &gt; <span class="number">1</span>; --i)&#123;</div><div class="line">        hanoi( i - <span class="number">1</span>, sources, temp, target);  </div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move yello "</span> &lt;&lt; i &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move blue "</span> &lt;&lt; i &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        hanoi( i - <span class="number">1</span>, target, temp, sources);  </div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move blue "</span> &lt;&lt; i &lt;&lt; <span class="string">"from "</span> &lt;&lt; temp &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"move yello "</span> &lt;&lt; i &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"move blue "</span> &lt;&lt; i &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n = <span class="number">6</span>;</div><div class="line">    twoColorHannoi( n, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// move the yello 1from Ato B</span></div><div class="line"><span class="comment">// move the blue 1from Ato B</span></div><div class="line"><span class="comment">// move the yello 2from Ato C</span></div><div class="line"><span class="comment">// move the blue 2from Ato C</span></div><div class="line"><span class="comment">// move the yello 1from Bto C</span></div><div class="line"><span class="comment">// move the blue 1from Bto C</span></div><div class="line"><span class="comment">// move yello 3from Ato B</span></div><div class="line"><span class="comment">// move blue 3from Ato B</span></div><div class="line"><span class="comment">// move the yello 1from Cto B</span></div><div class="line"><span class="comment">// move the blue 1from Cto B</span></div><div class="line"><span class="comment">// move the yello 2from Cto A</span></div><div class="line"><span class="comment">// move the blue 2from Cto A</span></div><div class="line"><span class="comment">// move the yello 1from Bto A</span></div><div class="line"><span class="comment">// move the blue 1from Bto A</span></div><div class="line"><span class="comment">// move blue 3from Bto C</span></div><div class="line"><span class="comment">// move the yello 1from Ato C</span></div><div class="line"><span class="comment">// move the blue 1from Ato C</span></div><div class="line"><span class="comment">// move yello 2from Ato B</span></div><div class="line"><span class="comment">// move blue 2from Ato B</span></div><div class="line"><span class="comment">// move the yello 1from Cto A</span></div><div class="line"><span class="comment">// move the blue 1from Cto A</span></div><div class="line"><span class="comment">// move blue 2from Bto C</span></div><div class="line"><span class="comment">// move yello 1from Ato B</span></div><div class="line"><span class="comment">// move blue 1from Ato C</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-3-三色汉若塔问题"><a href="#5-3-三色汉若塔问题" class="headerlink" title="5.3 三色汉若塔问题"></a>5.3 三色汉若塔问题</h2><ul>
<li>问题描述：<ul>
<li>就是要把所有的黄色盘子最终都放在第二个柱子上（顺序还是小的在上，大的在下！），而蓝色的盘子全部放在第三根柱子上（从小到大）而红色的盘子全部放在第一根柱子上（从小到大）</li>
</ul>
</li>
</ul>
<!-- ![threeColorHannoi](./image/threeColorHannoi.jpg "Optional title")
![threeColorHannoi2](./image/threeColorHannoi2.jpg "Optional title") -->
<p><img src="https://github.com/muyinsuifeng/myleetcode/raw/master/image/threeColorHannoi.jpg" alt="threeColorHannoi" title="Optional title"><br><img src="https://github.com/muyinsuifeng/myleetcode/raw/master/image/threeColorHannoi2.jpg" alt="threeColorHannoi2" title="Optional title"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">三色汉诺塔 </span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hannoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> sources, <span class="keyword">char</span> temp, <span class="keyword">char</span> target)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>( n == <span class="number">1</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"move the red "</span> &lt;&lt; n &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"move the yello "</span> &lt;&lt; n &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"move the blue "</span> &lt;&lt; n &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        hannoi( n<span class="number">-1</span>, sources, target, temp);  </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"move the red "</span> &lt;&lt; n &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"move the yello "</span> &lt;&lt; n &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"move the blue "</span> &lt;&lt; n &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        hannoi( n<span class="number">-1</span>, temp, temp, target);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">twoColorHannoi</span><span class="params">( <span class="keyword">int</span> n, <span class="keyword">char</span> sources, <span class="keyword">char</span> temp, <span class="keyword">char</span> target)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">if</span>( n == <span class="number">3</span>)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move red "</span> &lt;&lt; n/<span class="number">3</span> &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move yello "</span> &lt;&lt; n/<span class="number">3</span> &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move blue "</span> &lt;&lt; n/<span class="number">3</span> &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move yello "</span> &lt;&lt; n/<span class="number">3</span> &lt;&lt; <span class="string">"from "</span> &lt;&lt; temp &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move res "</span> &lt;&lt; n/<span class="number">3</span> &lt;&lt; <span class="string">"from "</span> &lt;&lt; temp &lt;&lt; <span class="string">"to "</span> &lt;&lt; sources &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move yello "</span> &lt;&lt; n/<span class="number">3</span> &lt;&lt; <span class="string">"from "</span> &lt;&lt; target &lt;&lt; <span class="string">"to "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        hannoi( n/<span class="number">3</span><span class="number">-1</span>, sources, temp, target);</div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move red "</span> &lt;&lt; n/<span class="number">3</span> &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move yello "</span> &lt;&lt; n/<span class="number">3</span> &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move blue "</span> &lt;&lt; n/<span class="number">3</span> &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">        hannoi( n/<span class="number">3</span><span class="number">-1</span>, target, temp, sources);</div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move blue "</span> &lt;&lt; n/<span class="number">3</span> &lt;&lt; <span class="string">"from "</span> &lt;&lt; temp &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move yello "</span> &lt;&lt; n/<span class="number">3</span> &lt;&lt; <span class="string">"from "</span> &lt;&lt; temp &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move red "</span> &lt;&lt; n/<span class="number">3</span> &lt;&lt; <span class="string">"from "</span> &lt;&lt; temp &lt;&lt; <span class="string">"to "</span> &lt;&lt; target &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">        hannoi( n/<span class="number">3</span><span class="number">-1</span>, sources, target, temp);</div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move red "</span> &lt;&lt; n/<span class="number">3</span> &lt;&lt; <span class="string">"from "</span> &lt;&lt; target &lt;&lt; <span class="string">"to "</span> &lt;&lt; sources &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move yello "</span> &lt;&lt; n/<span class="number">3</span> &lt;&lt; <span class="string">"from "</span> &lt;&lt; target &lt;&lt; <span class="string">"to "</span> &lt;&lt; sources &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        hannoi( n/<span class="number">3</span><span class="number">-1</span>, temp, sources, target);</div><div class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"move yello "</span> &lt;&lt; n/<span class="number">3</span> &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>( i = n/<span class="number">3</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)&#123;</div><div class="line">            <span class="keyword">if</span>( i &gt; <span class="number">1</span>)</div><div class="line">                hannoi( i<span class="number">-1</span>, target, sources, temp);</div><div class="line">            <span class="built_in">cout</span>&lt;&lt; <span class="string">"move red "</span> &lt;&lt; i &lt;&lt; <span class="string">"from "</span> &lt;&lt; target &lt;&lt; <span class="string">"to "</span> &lt;&lt; sources &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">            <span class="built_in">cout</span>&lt;&lt; <span class="string">"move yello "</span> &lt;&lt; i &lt;&lt; <span class="string">"from "</span> &lt;&lt; target &lt;&lt; <span class="string">"to "</span> &lt;&lt; sources &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">if</span>( i &gt; <span class="number">1</span>)</div><div class="line">                hannoi( i<span class="number">-1</span>, temp, sources, target);</div><div class="line">            <span class="built_in">cout</span>&lt;&lt; <span class="string">"move yello "</span> &lt;&lt; i &lt;&lt; <span class="string">"from "</span> &lt;&lt; sources &lt;&lt; <span class="string">"to "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n = <span class="number">6</span>;</div><div class="line">    twoColorHannoi( n, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="6、蒙地卡罗法求PI"><a href="#6、蒙地卡罗法求PI" class="headerlink" title="6、蒙地卡罗法求PI"></a>6、蒙地卡罗法求PI</h1><ul>
<li>说明：<ul>
<li>蒙地卡罗为摩洛哥王国之首都，该国位于法国与义大利国境，以赌博闻名。蒙地卡罗的基本原理为以乱数配合面积公式来进行解题，这种以机率来解题的方式带有赌博的意味，虽然在精确度上有所疑虑，但其解题的思考方向却是个值得学习的方式。</li>
</ul>
</li>
<li>解法：<ul>
<li>蒙地卡罗的解法适用于与面积有关的题目，例如求PI值或椭圆面积，这边介绍如何求PI值；假设有一个圆半径为1，所以四分之一圆面积就为PI，而包括此四分之一圆的正方形面积就为1 <!-- ![MonteCarloGetPi](./image/MonteCarloGetPi.jpg "Optional title") -->
<img src="https://github.com/muyinsuifeng/myleetcode/raw/master/image/MonteCarloGetPi.jpg" alt="MonteCarloGetPi" title="Optional title"><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//半径为1的四分之一的圆的面积为Pi/4,然后包含那四分之一圆的正方形的面积为1</span></div><div class="line"><span class="comment">//Pi/4 = ((0,0)-(1,1)的随机数中的点到(0,0)的长度小于1的概率)</span></div><div class="line"><span class="comment">//Pi = 4*c/n</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n = <span class="number">1000000000</span>;<span class="comment">//n用来代表投射的次数,也就是精度</span></div><div class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;<span class="comment">//落在圆上面的次数</span></div><div class="line">    srand(time(<span class="literal">NULL</span>));</div><div class="line">    <span class="keyword">double</span> x,y;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</div><div class="line">        x = (<span class="keyword">double</span>)(rand()/RAND_MAX);</div><div class="line">        y = (<span class="keyword">double</span>)(rand()/RAND_MAX);</div><div class="line">        <span class="keyword">if</span> ((x*x+y*y) &lt; <span class="number">1.0</span>)</div><div class="line">            c++;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the Pi is: "</span>&lt;&lt;(<span class="keyword">double</span>)<span class="number">4</span>*c/n&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[bitOperation]]></title>
      <url>/2017/08/24/bitOperation/</url>
      <content type="html"><![CDATA[<h1 id="1、single-Number"><a href="#1、single-Number" class="headerlink" title="1、single Number"></a>1、single Number</h1><h2 id="1-1-single-Number-I"><a href="#1-1-single-Number-I" class="headerlink" title="1.1 single Number I"></a>1.1 single Number I</h2><a id="more"></a>
<ul>
<li>说明：<ul>
<li>一个数组里面的所有数都是俩个，只有一个数是一个，返回那个只出现了一次的数</li>
</ul>
</li>
<li>思路：<ul>
<li>采用位运算的方法，假设对于a, a, b, b, c, c, d 这个数组res = a^a^b^b^c^c^d = (a^a)^(b^b)^(c^c)^d = 0^0^0^d = d 返回res即可<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) res ^= num;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="1-2-single-Number-II"><a href="#1-2-single-Number-II" class="headerlink" title="1.2 single Number II"></a>1.2 single Number II</h2><ul>
<li>说明：<ul>
<li>如果把数组中出现俩个的数都变为出现三次，返回那个只出现过一次的数</li>
</ul>
</li>
<li><p>思路：</p>
<ul>
<li>首先在记录的时候有出现1次，2次，3次这3种情况，所以要用两位high和low来记录出现的次数00 表示0次（3次相当于0次）， 01表示1次， 10 表示2次， 然后要有一个输入位input</li>
<li>| high | low | input | high_output | low_output |<br>| —- | — | —– | ———– |———– |<br>| 0 | 0 | 0 | 0 | 0 |<br>| 0 | 1 | 0 | 0 | 1 |<br>| 1 | 0 | 0 | 1 | 0 |<br>| 0 | 0 | 1 | 0 | 1 |<br>| 0 | 1 | 1 | 1 | 0 |<br>| 1 | 0 | 1 | 0 | 0 |</li>
<li>我们可以发现 low_output = low&amp;(~high)&amp;(~input) | (~low)&amp;(~high)&amp;input = (~high)&amp;(low^input)</li>
<li>high_output = (~low)&amp;high&amp;(~input) | low&amp;(~high)&amp;input<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumberII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span>  </span>&#123;  </div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> num : nums)&#123;  </div><div class="line">        <span class="keyword">int</span> temp_low = (low ^ num) &amp; ~high;  </div><div class="line">        high =(high&amp;~low&amp;~num)|(~high&amp;low&amp;num);  </div><div class="line">        low=temp_low;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> low;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>改进：</p>
<ul>
<li>low的计算保持不变，当我们计算完low之后，high的计算公式依赖的是旧的low值，我们设法将依赖旧low值改为依赖新low值</li>
<li>| high | low(low_output) | input | high_output |<br>| —- | — | —– | ———– |<br>| 0 | 0 | 0 | 0 |<br>| 0 | 1 | 0 | 0 |<br>| 1 | 0 | 0 | 1 |<br>| 0 | 1 | 1 | 0 |<br>| 0 | 0 | 1 | 1 |<br>| 1 | 0 | 1 | 0 |</li>
<li>high_output = high&amp;(~low)&amp;(~input) | (~high)&amp;(~low)&amp;input = (~low)&amp;(high^input)<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumberII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span>  </span>&#123;  </div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> num : nums)&#123;  </div><div class="line">        low = (low ^ num) &amp; ~high;  </div><div class="line">        high = (high ^ num) &amp; ~low;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> low;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-1考虑下如果把数组中出现俩个的数都变为出现n次，返回那个只出现过一次的数"><a href="#1-2-1考虑下如果把数组中出现俩个的数都变为出现n次，返回那个只出现过一次的数" class="headerlink" title="1.2.1考虑下如果把数组中出现俩个的数都变为出现n次，返回那个只出现过一次的数"></a>1.2.1考虑下如果把数组中出现俩个的数都变为出现n次，返回那个只出现过一次的数</h3><ul>
<li>思路：  <ul>
<li>考虑当n为偶数的时候直接用1.1的方法即可</li>
<li>当n为奇数的时候，假设n = 2*k+1 (0&lt;=k) .我们以7为例那就有出现1,2,3,4,5,6,7(相当于0次)的7种情况。那么我们需要3位数来表示</li>
<li>| three | two | one | input | three_output |two_output | one_output |  res |<br>| —– | — | — | —– |————- |———- |———– | —–|<br>| 0 | 0 | 0 | 0 | 0 | 0 | 0 |<br>| 0 | 0 | 1 | 0 | 0 | 0 | 1 | 输出 |<br>| 0 | 1 | 0 | 0 | 0 | 1 | 0 |<br>| 0 | 1 | 1 | 0 | 0 | 1 | 1 |<br>| 1 | 0 | 0 | 0 | 1 | 0 | 0 |<br>| 1 | 0 | 1 | 0 | 1 | 0 | 1 |<br>| 1 | 1 | 0 | 0 | 1 | 1 | 0 |<br>| 0 | 0 | 0 | 1 | 0 | 0 | 1 | 输出 |<br>| 0 | 0 | 1 | 1 | 0 | 1 | 0 |<br>| 0 | 1 | 0 | 1 | 0 | 1 | 1 |<br>| 0 | 1 | 1 | 1 | 1 | 0 | 0 |<br>| 1 | 0 | 0 | 1 | 1 | 0 | 1 |<br>| 1 | 0 | 1 | 1 | 1 | 1 | 0 |<br>| 1 | 1 | 0 | 1 | 0 | 0 | 0 |</li>
<li>然后根据要输出001的情况来写转换式<h2 id="1-3-single-Number-III"><a href="#1-3-single-Number-III" class="headerlink" title="1.3 single Number III"></a>1.3 single Number III</h2></li>
</ul>
</li>
<li>说明：<ul>
<li>把1.1中只有一个数字出现一次改为恰有两个数字出现一次，返回那两个数</li>
</ul>
</li>
<li>思路：<ul>
<li>如果能想办法把原数组分为两个小数组，不相同的两个数字分别在两个小数组中，这样分别调用Single Number 单独的数字的解法就可以得到答案。那么如何实现呢，首先我们先把原数组全部异或起来，那么我们会得到一个数字，这个数字是两个不相同的数字异或的结果，我们取出其中任意一位为‘1’的位，为了方便起见，我们用 a &amp;= -a 来取出最右端为‘1’的位，然后和原数组中的数字挨个相与，为0的分一个组，不为0的分一个组（因为是异或，所以这个1肯定来自一个数），那么我们要求的两个不同的数字就被分到了两个小组中，分别将两个小组中的数字都异或起来，就可以得到最终结果了</li>
<li>例如：<ul>
<li>1, 1, 2, 2, 3, 5</li>
<li>可以求出a = 0110 =&gt; a&amp;=-a =&gt;a = 0010</li>
<li>a&amp;1 == 0 res[0] ^= 1 =&gt;res[0] = 0001 =&gt;a&amp;1 =&gt;res[0] = 0000</li>
<li>a&amp;2 == 1 res[1] ^= 2 =&gt;res[1] = 0010 =&gt;a&amp;2 =&gt;res[1] = 0000</li>
<li>a&amp;3 == 1 res[1] ^= 3 =&gt; res[1] = 0011 = 3</li>
<li>a&amp;5 == 0 res[0] ^= 5 =&gt;res[0] = 0101 = 5</li>
<li>即可<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; singleNumberIII( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</div><div class="line">    <span class="keyword">int</span> a = accumulate( nums.begin(), nums.end(), <span class="number">0</span>, bit_xor&lt;<span class="keyword">int</span>&gt;());</div><div class="line">    a &amp;= -a;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> num : nums)&#123;</div><div class="line">        <span class="keyword">if</span>( num &amp; a) res[<span class="number">0</span>] ^= num;</div><div class="line">        <span class="keyword">else</span> res[<span class="number">1</span>] ^= num;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="2、位运算的实用技巧"><a href="#2、位运算的实用技巧" class="headerlink" title="2、位运算的实用技巧"></a>2、位运算的实用技巧</h1><p><a href="http://www.matrix67.com/blog/archives/264" target="_blank" rel="external">reference1</a><br><a href="http://www.matrix67.com/blog/archives/266" target="_blank" rel="external">reference2</a><br><a href="http://www.matrix67.com/blog/archives/268" target="_blank" rel="external">reference3</a><br>原文为pascal，我这里参考地修改为c++</p>
<h2 id="2-1-进阶"><a href="#2-1-进阶" class="headerlink" title="2.1 进阶"></a>2.1 进阶</h2><h3 id="2-1-1-二进制中的1有奇数个还是偶数个"><a href="#2-1-1-二进制中的1有奇数个还是偶数个" class="headerlink" title="2.1.1 二进制中的1有奇数个还是偶数个"></a>2.1.1 二进制中的1有奇数个还是偶数个</h3><ul>
<li>说明：<ul>
<li>计算一个32位整数的二进制的1的个数是奇数还是偶数</li>
</ul>
</li>
<li><p>思路1：</p>
<ul>
<li>每移一位如果是1就加到res，最后判断res的奇偶性 <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">long</span> x = <span class="number">1314523</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>( i++ &lt; <span class="number">32</span>)&#123;</div><div class="line">        res += x&amp;<span class="number">1</span>;</div><div class="line">        x &gt;&gt;= <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; (res&amp;<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>思路2：</p>
<ul>
<li>这效率其实并不高</li>
<li>下面那个代码就十分的高效，拿1314520(101000000111011011000)为例子</li>
<li>  x        0000 0000 0001 0100 0000 1110 1101 1000<br>  ^(x&gt;&gt;1)  0 0000 0000 0001 0100 0000 1110 1101 100<br>  x        0000 0000 0001 1110 0000 1001 1011 0100</li>
<li>这里得到一个新数，其中右起的i th个数表示原来的数中第i和i+1位上的1的个数是奇数还是偶数，比如，最右边那个0表示原数末两位有偶数个1，右起第3位上的1就表示原数的这个位置和前一个位置中有奇数个1</li>
<li>x        0000 0000 0001 1110 0000 1001 1011 0100<br>^(x&gt;&gt;2)  00 0000 0000 0001 1110 0000 1001 1011 01<br>x        0000 0000 0001 1001 1000 1011 1101 1001</li>
<li>结果里的每个1表示原数的该位置及其前面三个位置中共有奇数个1，每个0就表示原数对应的四个位置上共偶数个1。一直做到第五次异或结束后，得到的二进制数的最末位就表示整个32位数里有多少个1<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">long</span> x = <span class="number">1314523</span>;</div><div class="line">    x ^= (x &gt;&gt; <span class="number">1</span>);</div><div class="line">    x ^= (x &gt;&gt; <span class="number">2</span>);</div><div class="line">    x ^= (x &gt;&gt; <span class="number">4</span>);</div><div class="line">    x ^= (x &gt;&gt; <span class="number">8</span>);</div><div class="line">    x ^= (x &gt;&gt; <span class="number">16</span>);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; (x&amp;<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="2-1-2-二进制中的1的个数"><a href="#2-1-2-二进制中的1的个数" class="headerlink" title="2.1.2 二进制中的1的个数"></a>2.1.2 二进制中的1的个数</h3><ul>
<li><p>同样假设x为一个32位整数，在经过下面五次赋值运算后，x的值就是原数的1的个数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">long</span> x = <span class="number">1314520</span>;</div><div class="line">    x = (x &amp; <span class="number">0x55555555</span>) + ( ( x&gt;&gt;<span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</div><div class="line">    x = (x &amp; <span class="number">0x33333333</span>) + ( ( x&gt;&gt;<span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</div><div class="line">    x = (x &amp; <span class="number">0x0f0f0f0f</span>) + ( ( x&gt;&gt;<span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</div><div class="line">    x = (x &amp; <span class="number">0x00ff00ff</span>) + ( ( x&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</div><div class="line">    x = (x &amp; <span class="number">0x0000ffff</span>) + ( ( x&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; x;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>为了方便,我们先拿一个比较小的数，解释比如211(1101 0011)</p>
</li>
<li>1101 0011</li>
<li>10 01 00 10 第一次计算</li>
<li>0011 0010   第二次计算</li>
<li>0000 0101   第三次计算</li>
<li>这里使用的是分治的思想，第一次把相邻的两位加起来，得到每两位里的1的个数.如上面的10 01 00 10分表表示1101 0011中分为四部分，每份的1的个数为10(2), 01(1), 00(0), 10(2).第二次继续两两相加，10 + 01 = 0011 ,00 + 10 = 0010.就这样一直算到最后就是1的个数.这里面巧妙地运用了取位和右移，比如0x33333333(00110011001100110011…)，用它和x &amp;相当于以2为单位间隔取数。然后(x&gt;&gt;2) &amp; 0x33333333取到，x&amp;0x33333333未取得剩下的数，相加.</li>
</ul>
<h3 id="2-1-3-二分查找32位整数的前导0个数"><a href="#2-1-3-二分查找32位整数的前导0个数" class="headerlink" title="2.1.3 二分查找32位整数的前导0个数"></a>2.1.3 二分查找32位整数的前导0个数</h3><p>-<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">long</span> x = <span class="number">1314520</span>;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span>(<span class="number">32</span>);</div><div class="line">    n = <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> ((x &gt;&gt; <span class="number">16</span>) == <span class="number">0</span>) &#123;</div><div class="line">        n += <span class="number">16</span>; </div><div class="line">        x &lt;&lt;= <span class="number">16</span>;</div><div class="line">    &#125;<span class="comment">//先算前16(一半)是不是都为0，如果是n+=16,x左移16位</span></div><div class="line">    <span class="keyword">if</span> ((x &gt;&gt; <span class="number">24</span>) == <span class="number">0</span>) &#123;</div><div class="line">        n += <span class="number">8</span>; </div><div class="line">        x &lt;&lt;= <span class="number">8</span>;</div><div class="line">    &#125;<span class="comment">//如果，上一步执行了然后算16-24位是不是都为0，如果是n+=8,x左移8位</span></div><div class="line">    <span class="comment">//否则，算前8位是不是为0，如果是n+=8,x左移8位</span></div><div class="line">    <span class="keyword">if</span> ((x &gt;&gt; <span class="number">28</span>) == <span class="number">0</span>) &#123;</div><div class="line">        n += <span class="number">4</span>; </div><div class="line">        x &lt;&lt;= <span class="number">4</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ((x &gt;&gt; <span class="number">30</span>) == <span class="number">0</span>) &#123;</div><div class="line">        n += <span class="number">2</span>; </div><div class="line">        x &lt;&lt;= <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    n -= (x &gt;&gt; <span class="number">31</span>);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; n;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-1-4-只用位运算来取绝对值"><a href="#2-1-4-只用位运算来取绝对值" class="headerlink" title="2.1.4 只用位运算来取绝对值"></a>2.1.4 只用位运算来取绝对值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> x = <span class="number">-1314520</span>;</div><div class="line">    x = (x &gt;&gt; <span class="number">31</span>) == <span class="number">0</span>? x : (~x+<span class="number">1</span>);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; x;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//或者</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> x = <span class="number">-1314520</span>;</div><div class="line">    x = ((x &gt;&gt; <span class="number">31</span>) ^ x) - (x &gt;&gt; <span class="number">31</span>);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; x;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-1-5-高低位交换"><a href="#2-1-5-高低位交换" class="headerlink" title="2.1.5 高低位交换"></a>2.1.5 高低位交换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> x = <span class="number">1314520</span>;</div><div class="line">    x = ( x &gt;&gt; <span class="number">16</span>) | ( x &lt;&lt; <span class="number">16</span>);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; x;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-2-实例"><a href="#2-2-实例" class="headerlink" title="2.2 实例"></a>2.2 实例</h2><h3 id="2-2-1-n皇后问题"><a href="#2-2-1-n皇后问题" class="headerlink" title="2.2.1 n皇后问题"></a>2.2.1 n皇后问题</h3><ul>
<li>之前在DFS-algorithm中遇到过这里就不写了<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//其中核心的代码，也就是判断能否放置Q的代码如下</div><div class="line">    void test( int row, int ld, int rd)&#123;//row ld rd分别表示在纵列，和俩个对角线方向的限制下，在一行哪些地方不能放，冲突的位置放1</div><div class="line">                                            //把这三个条件并起来取反就得到了这一行可以放置的位置pos</div><div class="line">        int pos, p;</div><div class="line">        if( row != upperlim)&#123;</div><div class="line">            pos = upperlim &amp; (~(row| ld| rd));</div><div class="line">            while( pos)&#123;</div><div class="line">                p = pos &amp; ( ~pos + 1);</div><div class="line">                pos = pos - p;</div><div class="line">                test( row|p, (ld|p) &lt;&lt; 1, (rd|p) &gt;&gt; 1);</div><div class="line">            &#125;</div><div class="line">        &#125;else</div><div class="line">            ++Ans;</div><div class="line">    &#125;</div><div class="line">    upperlim = (1 &lt;&lt; n ) - 1;</div><div class="line">    Ans = 0;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-2-2-Gray码"><a href="#2-2-2-Gray码" class="headerlink" title="2.2.2 Gray码"></a>2.2.2 Gray码</h3><ul>
<li>Gray码是啥<ul>
<li>00     000<br>01  =&gt; 001<br>10     010<br>11     011<pre><code>111
110
101
100
</code></pre></li>
<li>可以发现，n = 3时 是n = 2时除去第一位后的镜像对称，以此类推</li>
<li>这种编码的顺序就叫Gray码:n阶的Gray码相当于在n维立方体上的Hamilton回路，因为沿着立方体上的边走一步，n维坐标中只会有一个值改变。再比如，Gray码和Hanoi塔问题等价。Gray码改变的是第几个数，Hanoi塔就该移动哪个盘子。比如，3阶的Gray码每次改变的元素所在位置依次为1-2-1-3-1-2-1，这正好是3阶Hanoi塔每次移动盘子编号。如果我们可以快速求出Gray码的第n个数是多少，我们就可以输出任意步数后Hanoi塔的移动步骤。现在我告诉你，Gray码的第n个数（从0算起）是n xor (n shr 1)，你能想出来这是为什么吗？先自己想想吧。</li>
<li>我们来分析一下二进制数和Gray码</li>
<li><pre><code>000       000
001       001
010       011
011       010
100       110
101       111
110       101
111       100
</code></pre></li>
<li>我们可以发现，从二进制数的角度看，”镜像”位置上的数即是对原数进行not后的结果。假设这两个数分别为x和y，那么x^(x&gt;&gt;1) 和 y(y&gt;&gt;1)的结果刚好就是首位不一样，前者为0，后者为1，刚好是Gray码的生成方法=&gt; Gray码的第n个数为n^(n&gt;&gt;1)</li>
</ul>
</li>
<li>我们来看个例题：<ul>
<li>这是一道二维意义上的Gray码，把[0, 2^( n+m)-1]的数写成2^n * 2^m 的矩阵，使得位置相邻的两个数的二进制表示只差一位.<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> m = <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> n = <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> u = <span class="number">0</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v( (<span class="number">1</span>&lt;&lt;m), <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;((<span class="number">1</span>&lt;&lt;n)));</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;m); ++i)&#123;</div><div class="line">        u = (i ^(i&gt;&gt;<span class="number">1</span>)) &lt;&lt; n;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span>&lt;&lt;n); ++j)</div><div class="line">            v[i][j] = u|((j ^ (j&gt;&gt;<span class="number">1</span>)));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> i : v)&#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> j : i)</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; j &lt;&lt; ends;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//0 1 3 2</span></div><div class="line"><span class="comment">// 4 5 7 6</span></div><div class="line"><span class="comment">//12 13 15 14</span></div><div class="line"><span class="comment">//8 9 11 10</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-3-费解的开关"><a href="#2-2-3-费解的开关" class="headerlink" title="2.2.3 费解的开关"></a>2.2.3 费解的开关</h3><ul>
<li>说明：<ul>
<li>你玩过“拉灯”游戏吗？25盏灯排成一个5×5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。<br>我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。</li>
<li>给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。</li>
<li>思路：<ul>
<li>首先可以把25个灯表示成25位二进制，然后转成十进制，灯的转换可以用’要转换的灯 xor 1’来实现，本题需要6步来实现的话，要是用反向BFS，搜索6步，然后将结果存到hash中，然后查找hash中是否存在给定的初始状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-4-garden-和MM逛花园"><a href="#2-2-4-garden-和MM逛花园" class="headerlink" title="2.2.4  garden / 和MM逛花园"></a>2.2.4  garden / 和MM逛花园</h3><ul>
<li>说明：<ul>
<li>花园设计强调，简单就是美。Matrix67常去的花园有着非常简单的布局：花园的所有景点的位置都是“对齐”了的，这些景点可以看作是平面坐标上的格点。相邻的景点之间有小路相连，这些小路全部平行于坐标轴。景点和小路组成了一个“不完整的网格”。一个典型的花园布局如左图所示。花园布局在6行4列的网格上，花园的16个景点的位置用红色标注在了图中。黑色线条表示景点间的小路，其余灰色部分实际并不存在。要不重复的一次性游玩整个花园</li>
<li><img src="https://github.com/muyinsuifeng/myleetcode/raw/master/image/visitGarden.gif" alt="visitGarden"></li>
</ul>
</li>
<li>思路：<ul>
<li>直接枚举所有的出使情况的DFS，用位运算把每一行(已走过的点为1)的状态存下，用来判断该点是否走过</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> bitOperation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[binarytree-algorithm]]></title>
      <url>/2017/08/24/binarytree-algorithm/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/felixfang/p/3828915.html" target="_blank" rel="external">http://www.cnblogs.com/felixfang/p/3828915.html</a></p>
<h1 id="1、求两个节点的最低公共祖先"><a href="#1、求两个节点的最低公共祖先" class="headerlink" title="1、求两个节点的最低公共祖先"></a>1、求两个节点的最低公共祖先</h1><a id="more"></a>
<ul>
<li>对于给定二叉树，输入两个树节点，求它们的最低公共祖先<h2 id="1-1特殊情况-有parent节点"><a href="#1-1特殊情况-有parent节点" class="headerlink" title="1.1特殊情况  有parent节点"></a>1.1特殊情况  有parent节点</h2></li>
<li>如果当<strong>节点带有parent指针</strong>时，可以方便的从给定的节点便利到根节点，这是求最低公共祖先，就是求两链表的第一个交点<ul>
<li>首先需要考虑空指针输入，有一个输入为NULL，就不会有点交点<ul>
<li>1、如果一个有环一个无环，则肯定没交点</li>
<li>2、如果都没无环寻找两链表的第一个交点，就是先求出两链表长度差diff后，让长的链表先走diff，然后一次比较，若相等则返回</li>
<li>3、在两个链表都有环的情况下，如果一个环的入口在另一个环上，则返回true</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode* <span class="title">traverse</span><span class="params">(ListNode* head, <span class="keyword">int</span> &amp;len, <span class="keyword">bool</span> &amp;circled)</span></span>&#123;</div><div class="line">    ListNode* p1 = head -&gt; next, *p2 = head -&gt; next;</div><div class="line">    <span class="keyword">int</span> step = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(; p2 != <span class="literal">NULL</span>; ++step, p1 = p1 -&gt; next, p2 = p2 -&gt; next)&#123;</div><div class="line">        p2 = p2 -&gt; next;</div><div class="line">        ++step;</div><div class="line">        <span class="keyword">if</span>(!p2 || p1 == p2) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!p2)&#123;    <span class="comment">//无环 </span></div><div class="line">        len = step;    <span class="comment">//用len记录链表长度 </span></div><div class="line">        circled = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//有环 </span></div><div class="line">        circled = <span class="literal">true</span>; </div><div class="line">        len = <span class="number">0</span>; <span class="comment">//用len记录头结点到环入口距离 </span></div><div class="line">        <span class="keyword">for</span>(p1 = head; p1 != p2; p1 = p1 -&gt; next, p2 = p2 -&gt; next, ++len);</div><div class="line">        <span class="keyword">return</span> p1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function">ListNode* <span class="title">FindFirstCommonListNode</span><span class="params">(ListNode* head1, ListNode* head2)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>( !head1 || !head2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">if</span>( head1 == head2) <span class="keyword">return</span> head1;</div><div class="line">    <span class="keyword">int</span> len1 = <span class="number">0</span>, len2 = <span class="number">0</span>; <span class="keyword">bool</span> cc1 = <span class="literal">false</span>, cc2 = <span class="literal">false</span>;</div><div class="line">    ListNode* CcleEnt1 = traverse(head1, len1, cc1);</div><div class="line">    ListNode* CcleEnt2 = traverse(head2, len2, cc2);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>((!cc1 &amp;&amp; cc2) || (cc1 &amp;&amp; !cc2)) <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">//若一个有环，一个无环，则肯定没有交点</span></div><div class="line">    <span class="keyword">if</span>(len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">0</span>)&#123;    <span class="comment">//当两链表都无环，或者都有环且首节点都不在环上时 </span></div><div class="line">        ListNode *st1 = (len1 &gt; len2 ? head1 : head2);</div><div class="line">        ListNode *st2 = (len1 &gt; len2 ? head2 : head1);</div><div class="line">        ListNode *cce1 = (len1 &gt; len2 ? CcleEnt1 : CcleEnt2);</div><div class="line">        ListNode *cce2 = (len1 &gt; len2 ? CcleEnt2 : CcleEnt1);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (len1 - len2 &gt; <span class="number">0</span> ? len1 - len2 : len2 - len1); ++i, st1 = st1 -&gt; next);</div><div class="line">        <span class="keyword">for</span>(; st1 != cce1 &amp;&amp; st2 != cce2 &amp;&amp; (st1 != st2); st1 = st1 -&gt; next, st2 = st2 -&gt; next);</div><div class="line">        <span class="keyword">if</span>(st1) <span class="keyword">return</span> st1;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;    <span class="comment">//len1, len2 中有一个为0 说明其中至少有一条链表是纯环链表。</span></div><div class="line">        ListNode *st1 = (len1 == <span class="number">0</span> ? head1 : head2); <span class="comment">//选择那个纯环链表的head，验证它是否在另一个链表的环上，在的话它就是第一个交点，不在的话就没有交点。 </span></div><div class="line">        ListNode *st2 = (len1 == <span class="number">0</span> ? head2 : head1);</div><div class="line">        ListNode *p = st2 -&gt; next;</div><div class="line">        <span class="keyword">for</span>(; p != st2 &amp;&amp; p != st1; p = p -&gt; next);</div><div class="line">        <span class="keyword">if</span>(p == st1) <span class="keyword">return</span> st1;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1-2、特殊情况-搜索二叉树"><a href="#1-2、特殊情况-搜索二叉树" class="headerlink" title="1.2、特殊情况  搜索二叉树"></a>1.2、特殊情况  搜索二叉树</h2><ul>
<li>如果在<strong>没有parent指针</strong>，或者<strong>给定的是两个节点的数值而非节点的地址</strong>，那么只有从根节点开始遍历一遍。( 对于一些特殊性质的二叉树，可以提高搜索效率)<ul>
<li>比如说BST可以将传统二叉树的遍历时间(O(n))降低到(O(logn))<ul>
<li>如果给定的节点在二叉树中，我们只需要将节点的值(a = q-&gt;val,b = p-&gt;val)和root-&gt;val比较，如果root-&gt;val在[a,b]则返回root，如果root-&gt;val 在(0, a)root = root-&gt;left继续，如果root-&gt;val 在( b, ..), 则root = root-&gt;right继续</li>
<li>如果给定节点的值 ，并不能保证这两个值(a, b)在二叉树中，相对于上面的算法，唯一的变化是:当root-&gt;val在[a,b]中时，我们不能断定最低公共祖先是root，需要在左(右)枝继续搜索a 或者b，才能断定最低公共祖先是root</li>
<li><pre><code>        7
   3        8
1     5
</code></pre>如上图当a = 2， b = 6时，搜索到3时可以看到3在[a,b]中但是,3并不是a,b的最小公共祖先，这个时候需要继续往左右枝进行搜索，会发现5才是。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-3-传统二叉树"><a href="#1-3-传统二叉树" class="headerlink" title="1.3 传统二叉树"></a>1.3 传统二叉树</h2><ul>
<li>对于普通的二叉树，只能从根节点开始找两个节点。</li>
<li><p>这里假设给定的是两个节点的val，并且这两节点不一定在树中，返回最小公共祖先的值，没有的话返回”not exist”</p>
<h3 id="解法一-time-O-2n-space-O-logn"><a href="#解法一-time-O-2n-space-O-logn" class="headerlink" title="解法一  time O(2n)  space O(logn)"></a>解法一  time O(2n)  space O(logn)</h3><p>TreeNode定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></div><div class="line">    TreeNode *left;</div><div class="line">    TreeNode *right;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    TreeNode(<span class="keyword">int</span> v): val(v), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>)&#123;&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>思路：</p>
<ul>
<li>我们先在root的左子树寻找a和b<ul>
<li>如果找到了，说明最低公共祖先在左子树，root = root-&gt;left</li>
<li>如果找不到，说明最低公共祖先只可能在右子树，root = root-&gt;right</li>
<li>若果找到了a 没找到b ，那就在右子树找b，如果找到了返回b<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findVal</span><span class="params">( TreeNode* root, <span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>( !root) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span>( root-&gt;val == v) <span class="keyword">return</span> ture;</div><div class="line">    <span class="keyword">return</span> findVal( root-&gt;right, v) || findVal( root-&gt;left, v);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">FindCmmnAncstr</span><span class="params">(TreeNode* node, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>( !ndoe) <span class="keyword">return</span> <span class="string">"not exist"</span>;</div><div class="line">    <span class="keyword">if</span>( node-&gt;val == a)&#123;</div><div class="line">        <span class="keyword">if</span>( findVal( node, b)) <span class="keyword">return</span> to_string(a);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"not exist"</span>;</div><div class="line">    &#125;<span class="keyword">if</span>( node-&gt;val == b)&#123;</div><div class="line">        <span class="keyword">if</span>( findVal( node, a)) <span class="keyword">return</span> to_string(b);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"not exist"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">bool</span> lefta = FindVal( node -&gt; left, a);</div><div class="line">    <span class="keyword">bool</span> leftb = FindVal( node -&gt; left, b);</div><div class="line">    <span class="keyword">if</span>( lefta &amp;&amp; leftb) <span class="keyword">return</span> FindCmmnAncstr( node -&gt; left, a, b);</div><div class="line">    <span class="keyword">if</span>( !lefta &amp;&amp; !leftb) <span class="keyword">return</span> FindCmmnAncstr( node -&gt; right, a, b);</div><div class="line">    <span class="keyword">if</span>( lefta)&#123;</div><div class="line">        <span class="keyword">if</span>( FindVal(node -&gt; right, b)) <span class="keyword">return</span> to_string(node -&gt; val);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"not exist"</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">if</span>(FindVal(node -&gt; right, a)) <span class="keyword">return</span> to_string(node -&gt; val);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"not exist"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="解法二-time-O-n-space-O-3logn"><a href="#解法二-time-O-n-space-O-3logn" class="headerlink" title="解法二 time O(n) space O(3logn)"></a>解法二 time O(n) space O(3logn)</h3><ul>
<li>上面的解法因为有节点被重复遍历，导致时间复杂度的提高</li>
<li>为了避免重复遍历，我们可以将找到a，b后所经过的节点路径存储下来，然后比较两条路径，找到相同的部分<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FindVal</span><span class="params">(TreeNode* node, <span class="keyword">int</span> v, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    path.push_back(node -&gt; val);</div><div class="line">    <span class="keyword">if</span>(node -&gt; val == v)    </div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">if</span>(FindVal(node -&gt; left, v, path) || FindVal(node -&gt; right, v, path))</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    path.pop_back();</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">FindCmmnAncstr2</span><span class="params">(TreeNode* node, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="string">"My God"</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path1; <span class="comment">//寻找a的经过路径</span></div><div class="line">    FindVal(node, a, path1);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path2; <span class="comment">//寻找b的经过路径</span></div><div class="line">    FindVal(node, b, path2);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it1 = path1.begin();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it2 = path2.begin();</div><div class="line">    <span class="keyword">int</span> acstor = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(; it1 &lt; path1.end() &amp;&amp; it2 &lt; path2.end() &amp;&amp; (*it1) == (*it2); acstor = *it2, ++it1, ++it2);</div><div class="line">    <span class="keyword">return</span> (acstor &gt; <span class="number">0</span> ? to_string(acstor) : <span class="string">"My God"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="解法三-time-O-3n-space-O-2logn"><a href="#解法三-time-O-3n-space-O-2logn" class="headerlink" title="解法三 time O(3n) space O(2logn)"></a>解法三 time O(3n) space O(2logn)</h3><ul>
<li><p>参考<a href="http://www.gocalf.com/blog/least-common-ancestor.html" target="_blank" rel="external">http://www.gocalf.com/blog/least-common-ancestor.html</a>,作者用到了NLR前序遍历来使得不用像方法二中那样缓存整条分支。</p>
<ul>
<li><p>我们这里不再使用地归来寻找节点，而改用栈来实现NLR</p>
<ul>
<li><p>用栈遍历如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">stack</span>&lt;TreeNode*&gt; st;</div><div class="line">st.push( root);</div><div class="line"><span class="keyword">while</span>( !st.empty())&#123;</div><div class="line">    TreeNode* node = st.top();</div><div class="line">    st.pop();</div><div class="line">    <span class="comment">//do something to node</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span>( node-&gt;left) st.push( node-&gt;left);</div><div class="line">    <span class="keyword">if</span>( node-&gt;right) st.push( node-&gt;right);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>修改后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">stack</span>&lt;TreeNode*&gt; st;</div><div class="line">st.push( root)</div><div class="line"><span class="keyword">while</span>(!st.empty())&#123;</div><div class="line">     TreeNode* node = st.top();</div><div class="line">     <span class="comment">//Do something to node.</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span>( node -&gt; left)&#123;</div><div class="line">        st.push( node -&gt; left);</div><div class="line">        node -&gt; left = <span class="literal">NULL</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        st.pop();</div><div class="line">        <span class="keyword">if</span>( node -&gt; right) st.push( node -&gt; right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>思路：</p>
<ul>
<li>对于LCA，只可能有一下两种情况<ul>
<li>1、LCA是其中一个节点，另一个是他的子孙</li>
<li>2、两个节点分别位于LCA的左右子树当中</li>
</ul>
</li>
<li><p>对于上面两种情况我们可以分别处理</p>
<ul>
<li>1、前序遍历首先找到的节点就是LCA，剩下的是就是确定第二个节点是否在他的下面</li>
<li><p>2、假设在前序遍历中，首先找到了一个节点( 如下图H),根据上面修改的非递归前序遍历的算法特性，这是stack里存储了A, B, D, G ，然后根据LCA的特性可以发现LCA要么是H自身要么是A, B, D, G，接下来只要继续遍历找到另一个节点，这时看看A, B, D, G谁还在栈里，下面的那个就是LCA</p>
<pre><code>       A
    B
C
    D
E
    F
        G
    H
</code></pre></li>
</ul>
</li>
<li>但是如果用上面的遍历方法的话，在寻找b的时候，如果b在H的子树上，在找到a的时候H已经被弹出了，所以要修改为如下<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">stack</span>&lt;TreeNode*&gt; st;</div><div class="line">st.push( root);</div><div class="line"><span class="keyword">while</span>( !st.empty())&#123;</div><div class="line">    TreeNode* node = st.back();</div><div class="line">    <span class="comment">//do something to node</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keyword">if</span>( node-&gt;left)&#123;</div><div class="line">        st.push( node-&gt;left);</div><div class="line">        node-&gt;left = <span class="literal">nullptr</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( node-&gt;right)&#123;</div><div class="line">        st.push( node-&gt;right);</div><div class="line">        node-&gt;right = <span class="literal">nullptr</span>;</div><div class="line">    &#125;<span class="keyword">else</span> st.pop();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>所以第三种方法可如如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">FindCmmnAncstr</span><span class="params">(TreeNode* node, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>( !node) <span class="keyword">return</span> <span class="string">"not exist"</span>;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</div><div class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; mp;<span class="comment">//mp用来标记此时在栈中的“最低公共祖先”候选人</span></div><div class="line">    st.push( node);</div><div class="line">    <span class="keyword">int</span> firstNumberAnother;<span class="comment">//记录第一个被找的数的另一个数</span></div><div class="line">    TreeNode* n = <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">while</span>( !st.empty())&#123;<span class="comment">//寻找第一个数</span></div><div class="line">        n = st.top();</div><div class="line">        <span class="comment">//do something to node</span></div><div class="line">        <span class="keyword">if</span>( n-&gt;val == a|| n-&gt;val == b)&#123;</div><div class="line">            firstNumberAnother = ( n-&gt;val == a)? b: a;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( n-&gt;left)&#123;</div><div class="line">            st.push( n-&gt;left);</div><div class="line">            n-&gt;left = <span class="literal">nullptr</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            st.pop();</div><div class="line">            <span class="keyword">if</span>( n -&gt; right) st.push( n -&gt; right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>( st.empty()) <span class="keyword">return</span> <span class="string">"not exist"</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt;::iterator it = st.begin();</div><div class="line">    <span class="keyword">for</span>( ; it != st.end(); ++it)</div><div class="line">        mp[*it] ++;</div><div class="line">    <span class="keyword">while</span>(!st.empty())&#123; <span class="comment">//寻找firstNumberAnother的过程</span></div><div class="line">        n = st.top();</div><div class="line">        <span class="keyword">if</span>(n -&gt; val == firstNumberAnother) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span>(n -&gt; left)&#123;</div><div class="line">            st.push(n -&gt; left);</div><div class="line">            n -&gt; left = <span class="literal">nullptr</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n -&gt; right)&#123;</div><div class="line">            st.push(n -&gt; right);</div><div class="line">            n -&gt; right = <span class="literal">nullptr</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            st.pop();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>( !st.empty())&#123;<span class="comment">//从上到下遍历栈，找到第一个被标记为“候选人”的节点就是最低公共祖先。</span></div><div class="line">        <span class="keyword">if</span>( mp.count( st.top())) <span class="keyword">return</span> to_string( st.top()-&gt;val);</div><div class="line">        st.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">"not exist"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> binarytree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[my-first-blog]]></title>
      <url>/2017/08/22/my-first-blog/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用github pages服务搭建博客的好处有：</p>
<ol>
<li>全是静态文件，访问速度快；</li>
<li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li>
<li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li>
</ol>
<a id="more"></a>
<ol>
<li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li>
<li>博客内容可以轻松打包、转移、发布到其它平台；</li>
<li>等等；</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Blog-readme </category>
            
        </categories>
        
        
        <tags>
            
            <tag> readme </tag>
            
            <tag> before read </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World "guoming-test"]]></title>
      <url>/2017/08/22/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
